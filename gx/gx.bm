'OPTION _EXPLICIT
''$include: '../gx/gx.bi'
'SUB GXOnGameEvent (event AS GXEvent)
'END SUB

SUB GXSleep (stime)
    _DELAY stime
END SUB

FUNCTION GXSoundLoad (filename AS STRING)
    $IF MACOSX THEN
        ' Sound not currently supported for macosx
    $ELSE
        GXSoundLoad = _SNDOPEN(filename)
    $END IF
END FUNCTION

SUB GXSoundPlay (sid AS LONG)
    $IF MACOSX THEN
        ' Sound not currently supported for macosx
    $ELSE
        _SNDPLAY sid
    $END IF
END SUB

SUB GXSoundRepeat (sid AS LONG)
    $IF MACOSX THEN
        ' Sound not currently supported for macosx
    $ELSE
        _SNDLOOP sid
    $END IF
END SUB

SUB GXSoundVolume (sid AS LONG, v)
    $IF MACOSX THEN
        ' Sound not currently supported for macosx
    $ELSE
        _SNDVOL sid, v / 100
    $END IF
END SUB

SUB GXSoundPause (sid AS LONG)
    $IF MACOSX THEN
        ' Sound not currently supported for macosx
    $ELSE
        _SNDPAUSE sid
    $END IF
END SUB

SUB GXSoundStop (sid AS LONG)
    $IF MACOSX THEN
        ' Sound not currently supported for macosx
    $ELSE
        _SNDSTOP sid
    $END IF
END SUB


FUNCTION GXImageLoad (filename AS STRING)
    DIM id AS LONG
    DIM i AS INTEGER
    FOR i = 0 TO gx_image_count - 1
        IF filename = gx_images(i).filename THEN id = gx_images(i).id
    NEXT i
    IF id = 0 THEN
        id = _LOADIMAGE(filename)
        gx_image_count = gx_image_count + 1
        REDIM _PRESERVE gx_images(gx_image_count) AS GXImage
        gx_images(gx_image_count - 1).id = id
        gx_images(gx_image_count - 1).filename = filename
    END IF
    GXImageLoad = id
END FUNCTION

SUB GXImageDraw (id AS INTEGER, x AS LONG, y AS LONG)
    _PUTIMAGE (x, y), id
END SUB

SUB GXEntityAnimate (eid AS INTEGER, seq AS INTEGER, a AS INTEGER)
    gx_entities(eid).animate = a
    gx_entities(eid).spriteSeq = seq
END SUB

SUB GXEntityAnimateOff (eid AS INTEGER)
    gx_entities(eid).animate = 0
END SUB

SUB GXEntityAnimateMode (eid AS INTEGER, mode AS INTEGER)
    gx_entities(eid).animateMode = mode
END SUB

FUNCTION GXEntityAnimateMode (eid AS INTEGER)
    GXEntityAnimateMode = gx_entities(eid).animateMode
END FUNCTION

FUNCTION GXScreenEntityCreate (imageFilename AS STRING, ewidth AS INTEGER, height AS INTEGER, seqFrames AS INTEGER)
    DIM eid AS INTEGER
    eid = GXEntityCreate(imageFilename, ewidth, height, seqFrames)
    gx_entities(eid).screen = 1
    GXScreenEntityCreate = eid
END FUNCTION

FUNCTION GXEntityCreate (imageFilename AS STRING, ewidth AS INTEGER, height AS INTEGER, seqFrames AS INTEGER)
    DIM newent AS GXEntity
    newent.x = 0
    newent.y = 0
    newent.height = height
    newent.width = ewidth
    newent.image = GXImageLoad(imageFilename)
    newent.spriteFrame = 1
    newent.spriteSeq = 1
    newent.seqFrames = seqFrames
    gx_entity_count = gx_entity_count + 1
    REDIM _PRESERVE gx_entities(gx_entity_count) AS GXEntity
    gx_entities(gx_entity_count) = newent
    GXEntityCreate = gx_entity_count
END FUNCTION

SUB GXEntityHide (eid AS INTEGER)
    gx_entities(eid).hidden = 1
END SUB

SUB GXEntityShow (eid AS INTEGER)
    gx_entities(eid).hidden = 0
END SUB

SUB GXEntityDraw (ent AS GXEntity)
    IF ent.hidden = 1 THEN EXIT SUB
    DIM x, y AS LONG
    IF ent.screen = 1 THEN
        x = ent.x
        y = ent.y
    ELSE
        x = ent.x - gx_scene.x
        y = ent.y - gx_scene.y
    END IF
    GXSpriteDraw ent.image, x, y, ent.spriteSeq, ent.spriteFrame, ent.width, ent.height, gx_scene.image
END SUB

SUB GXEntityMove (eid AS INTEGER, x AS LONG, y AS LONG)
    gx_entities(eid).x = gx_entities(eid).x + x
    gx_entities(eid).y = gx_entities(eid).y + y
END SUB


SUB GXEntityPos (eid AS INTEGER, x AS LONG, y AS LONG)
    gx_entities(eid).x = x
    gx_entities(eid).y = y
END SUB

SUB GXEntityVX (eid AS INTEGER, vx AS INTEGER)
    gx_entities(eid).vx = vx
END SUB

FUNCTION GXEntityVX (eid AS INTEGER)
    GXEntityVX = gx_entities(eid).vx
END FUNCTION

SUB GXEntityVY (eid AS INTEGER, vy AS INTEGER)
    gx_entities(eid).vy = vy
END SUB

FUNCTION GXEntityVY (eid AS INTEGER)
    GXEntityVY = gx_entities(eid).vy
END FUNCTION


FUNCTION GXEntityX (eid AS INTEGER)
    GXEntityX = gx_entities(eid).x
END FUNCTION

FUNCTION GXEntityY (eid AS INTEGER)
    GXEntityY = gx_entities(eid).y
END FUNCTION

FUNCTION GXEntityWidth (eid AS INTEGER)
    GXEntityWidth = gx_entities(eid).width
END FUNCTION

FUNCTION GXEntityHeight (eid AS INTEGER)
    GXEntityHeight = gx_entities(eid).height
END FUNCTION

SUB GXEntityFrameNext (eid AS INTEGER)
    IF gx_entities(eid).animateMode = GXANIMATE_SINGLE THEN
        IF gx_entities(eid).spriteFrame + 1 >= gx_entities(eid).seqFrames THEN
            EXIT SUB
        END IF
    END IF

    gx_entities(eid).spriteFrame = gx_entities(eid).spriteFrame + 1
    IF gx_entities(eid).spriteFrame > gx_entities(eid).seqFrames THEN
        gx_entities(eid).spriteFrame = 1
    END IF
END SUB

SUB GXEntityFrameSet (eid AS INTEGER, seq AS INTEGER, frame AS INTEGER)
    gx_entities(eid).spriteSeq = seq
    gx_entities(eid).spriteFrame = frame
END SUB

SUB GXEntityImageSet (eid AS INTEGER, filename AS STRING)
    gx_entities(eid).image = GXImageLoad(filename)
END SUB

SUB GXEntityType (eid AS INTEGER, etype AS INTEGER)
    gx_entities(eid).type = etype
END SUB

FUNCTION GXEntityType (eid AS INTEGER)
    GXEntityType = gx_entities(eid).type
END FUNCTION


' TODO: Replace this implementation with a hash table lookup so we can scale
'       efficiently when managing very large numbers of entities
' ----------------------------------------------------------------------------
SUB GXEntityUID (eid AS INTEGER, uid AS STRING * 10)
    gx_entities(eid).uid = uid
END SUB

FUNCTION GXEntityUID$ (eid AS INTEGER)
    GXEntityUID = gx_entities(eid).uid
END FUNCTION

FUNCTION GXEntityFind (uid AS STRING * 10)
    GXEntityFind = 0
    DIM i AS INTEGER
    FOR i = 1 TO gx_entity_count
        IF RTRIM$(gx_entities(i).uid) = uid THEN
            GXEntityFind = i
            EXIT FUNCTION
        END IF
    NEXT i
END FUNCTION
' ----------------------------------------------------------------------------


SUB GXEntityApplyGravity (eid AS INTEGER, gravity AS INTEGER)
    gx_entities(eid).applyGravity = gravity
END SUB

FUNCTION GXEntityApplyGravity (eid AS INTEGER)
    GXEntityApplyGravity = gx_entities(eid).applyGravity
END FUNCTION

SUB GXEntityCollisionOffsetSet (eid AS INTEGER, left AS INTEGER, top AS INTEGER, right AS INTEGER, bottom AS INTEGER)
    gx_entities(eid).coLeft = left
    gx_entities(eid).coTop = top
    gx_entities(eid).coRight = right
    gx_entities(eid).coBottom = bottom
END SUB

FUNCTION GXEntityCollisionOffsetLeft (eid AS INTEGER)
    GXEntityCollisionOffsetLeft = gx_entities(eid).coLeft
END FUNCTION

FUNCTION GXEntityCollisionOffsetTop (eid AS INTEGER)
    GXEntityCollisionOffsetTop = gx_entities(eid).coTop
END FUNCTION

FUNCTION GXEntityCollisionOffsetRight (eid AS INTEGER)
    GXEntityCollisionOffsetRight = gx_entities(eid).coRight
END FUNCTION

FUNCTION GXEntityCollisionOffsetBottom (eid AS INTEGER)
    GXEntityCollisionOffsetBottom = gx_entities(eid).coBottom
END FUNCTION


FUNCTION GXPlayerCreate (eid AS INTEGER)
    gx_player_count = gx_player_count + 1
    REDIM _PRESERVE gx_players(gx_player_count) AS GXPlayer
    REDIM _PRESERVE gx_player_keymap(10, gx_player_count) AS GXAction
    gx_players(gx_player_count).eid = eid
    gx_players(gx_player_count).walkSpeed = 60
    gx_players(gx_player_count).runSpeed = 120
    gx_players(gx_player_count).jumpSpeed = 120
    GXPlayerCreate = gx_player_count
END FUNCTION

SUB GXPlayerMoveSpeed (pid AS INTEGER, moveSpeed AS INTEGER)
    gx_players(pid).walkSpeed = moveSpeed
END SUB

SUB GXPlayerJumpSpeed (pid AS INTEGER, jumpSpeed AS INTEGER)
    gx_players(pid).jumpSpeed = jumpSpeed
END SUB

SUB GXPlayerActionKey (pid AS INTEGER, actionType AS INTEGER, k AS LONG)
    gx_player_keymap(actionType, pid).key = k
END SUB

FUNCTION GXPlayerActionKey (pid AS INTEGER, actionType AS INTEGER)
    GXPlayerActionKey = gx_player_keymap(actionType, pid).key
END FUNCTION

SUB GXPlayerActionMoveX (pid AS INTEGER, actionType AS INTEGER, movex AS INTEGER)
    gx_player_keymap(actionType, pid).movex = movex
END SUB

FUNCTION GXPlayerActionMoveX (pid AS INTEGER, actionType AS INTEGER)
    GXPlayerActionMoveX = gx_player_keymap(actionType, pid).movex
END FUNCTION

SUB GXPlayerActionMoveY (pid AS INTEGER, actionType AS INTEGER, movey AS INTEGER)
    gx_player_keymap(actionType, pid).movey = movey
END SUB

FUNCTION GXPlayerActionMoveY (pid AS INTEGER, actionType AS INTEGER)
    GXPlayerActionMoveY = gx_player_keymap(actionType, pid).movey
END FUNCTION

SUB GXPlayerActionAnimationSeq (pid AS INTEGER, actionType AS INTEGER, animationSeq AS INTEGER)
    gx_player_keymap(actionType, pid).animationSeq = animationSeq
END SUB

FUNCTION GXPlayerActionAnimationSeq (pid AS INTEGER, actionType AS INTEGER)
    GXPlayerActionAnimationSeq = gx_player_keymap(actionType, pid).animationSeq
END FUNCTION

SUB GXPlayerActionAnimationMode (pid AS INTEGER, actionType AS INTEGER, animationMode AS INTEGER)
    gx_player_keymap(actionType, pid).animationMode = animationMode
END SUB

FUNCTION GXPlayerActionAnimationMode (pid AS INTEGER, actionType AS INTEGER)
    GXPlayerActionAnimationMode = gx_player_keymap(actionType, pid).animationMode
END FUNCTION

SUB GXPlayerActionAnimationSpeed (pid AS INTEGER, actionType AS INTEGER, animationSpeed AS INTEGER)
    gx_player_keymap(actionType, pid).animationSpeed = animationSpeed
END SUB

FUNCTION GXPlayerActionAnimationSpeed (pid AS INTEGER, actionType AS INTEGER)
    GXPlayerActionAnimationSpeed = gx_player_keymap(actionType, pid).animationSpeed
END FUNCTION



SUB GXFullScreenOn
    _FULLSCREEN _SQUAREPIXELS
END SUB

SUB GXFullScreenOff
    _FULLSCREEN _OFF
END SUB

FUNCTION GXBackgroundAdd (imageFilename AS STRING)
    gx_bg_count = gx_bg_count + 1
    REDIM _PRESERVE gx_bg(gx_bg_count) AS GXBackground
    gx_bg(gx_bg_count).image = GXImageLoad(imageFilename)
    gx_bg(gx_bg_count).mode = GXBG_STRETCH
    GXBackgroundAdd = gx_bg_count
END FUNCTION

SUB GXBackgroundMode (gi AS INTEGER, mode AS INTEGER)
    gx_bg(gi).mode = mode
END SUB

SUB GXBackgroundY (gi AS INTEGER, y AS INTEGER)
    gx_bg(gi).y = y
END SUB

SUB GXBackgroundHeight (gi AS INTEGER, height AS INTEGER)
    gx_bg(gi).height = height
END SUB

SUB GXBackgroundClear
    gx_bg_count = 0
    REDIM gx_bg(0) AS GXBackground
END SUB

SUB GXBackgroundDraw (bi AS INTEGER)
    DIM factor, xfactor
    DIM w AS LONG, h AS LONG, x AS LONG, y AS LONG

    IF gx_bg(bi).mode = GXBG_STRETCH THEN
        _PUTIMAGE , gx_bg(bi).image, gx_scene.image

    ELSEIF gx_bg(bi).mode = GXBG_SCROLL THEN
        factor = gx_scene.width / gx_scene.height
        h = _HEIGHT(gx_bg(bi).image)
        w = h * factor
        'x = gx_bg(bi).xpos
        xfactor = GXSceneX / (GXMapColumns * GXTilesetWidth)
        x = xfactor * (_WIDTH(gx_bg(bi).image) - w)
        _PUTIMAGE , gx_bg(bi).image, gx_scene.image, (x, 0)-(x + w, h)

    ELSEIF gx_bg(bi).mode = GXBG_WRAP THEN
        h = gx_bg(bi).height
        w = GXSceneWidth
        y = gx_bg(bi).y
        x = (GXSceneX MOD _WIDTH(gx_bg(bi).image)) / 2
        _PUTIMAGE (0, y)-(GXSceneWidth, y + h), gx_bg(bi).image, gx_scene.image, (x, 0)-(x + w, _HEIGHT(gx_bg(bi).image))
        'if x +w > _WIDTH(gx_bg(bi).image) then
        '    dim w2 as LONG
        '    w2 = _Width(gx_bg(bi).image - x+w)
        '    _PUTIMAGE (GXSceneWidth-w2,y)-(GXSceneWidth,y+h) , gx_bg(bi).image, gx_img_scene, (0, 0)-(w2, _HEIGHT(gx_bg(bi).image))
        'end if

    END IF
END SUB

SUB GXSceneBGSet (imageFilename AS STRING)
    gx_bg_count = 1
    REDIM _PRESERVE gx_bg(gx_bg_count) AS GXBackground
    gx_bg(gx_bg_count).image = GXImageLoad(imageFilename)
    gx_bg(gx_bg_count).mode = GXBG_STRETCH
END SUB

SUB GXSceneBGClear
    GXBackgroundClear
END SUB

SUB GXSceneEmbedded (embedded AS INTEGER)
    gx_scene.embedded = embedded
END SUB

FUNCTION GXSceneEmbedded
    GXSceneEmbedded = gx_scene.embedded
END FUNCTION

SUB GXSceneCreate (swidth AS INTEGER, sheight AS INTEGER)
    gx_scene.width = swidth
    gx_scene.height = sheight

    IF gx_scene.embedded = 0 THEN
        SCREEN _NEWIMAGE(gx_scene.width, gx_scene.height, 32)
    END IF

    IF gx_scene.image THEN _FREEIMAGE gx_scene.image
    gx_scene.image = _NEWIMAGE(gx_scene.width, gx_scene.height, 32)

    IF NOT gx_img_blank THEN gx_img_blank = _NEWIMAGE(1, 1, 32)
END SUB

SUB GXSceneResize (swidth AS INTEGER, sheight AS INTEGER)
    gx_scene.width = swidth
    gx_scene.height = sheight

    IF gx_scene.image THEN _FREEIMAGE (gx_scene.image)
    gx_scene.image = _NEWIMAGE(gx_scene.width, gx_scene.height, 32)

    IF (gx_scene.embedded = 0) THEN
        SCREEN _NEWIMAGE(gx_scene.width, gx_scene.height, 32)
    END IF
    __GX_UpdateSceneSize
END SUB

SUB GXSceneDestroy
    GXSceneStop
    _FREEIMAGE gx_scene.image
    _FREEIMAGE gx_img_blank
    gx_scene.image = 0
    gx_img_blank = 0
    DIM i AS INTEGER
    FOR i = 0 TO gx_image_count - 1
        _FREEIMAGE gx_images(i).id
    NEXT i
    gx_image_count = 0
    REDIM gx_images(0) AS GXImage
END SUB

SUB __GX_CustomEvent (eventType AS INTEGER)
    DIM e AS GXEvent
    e.event = eventType
    GXOnGameEvent e
END SUB

SUB __GX_CustomDrawEvent (eventType AS INTEGER)
    _DEST gx_scene.image
    __GX_CustomEvent eventType
    _DEST 0
END SUB

SUB GXFrameRate (frameRate AS INTEGER)
    gx_framerate = frameRate
END SUB

FUNCTION GXFrameRate
    GXFrameRate = gx_framerate
END FUNCTION

SUB GXSceneDraw
    IF gx_map_loading THEN EXIT SUB
    DIM ei AS INTEGER
    DIM ei2 AS INTEGER
    DIM frame AS INTEGER
    'DIM aframe AS INTEGER
    frame = gx_ticks MOD gx_framerate + 1

    ' Clear the background
    _DONTBLEND gx_scene.image
    _PUTIMAGE , gx_img_blank, gx_scene.image
    _BLEND gx_scene.image

    ' Draw background images, if present
    DIM bi AS INTEGER
    FOR bi = 1 TO gx_bg_count
        GXBackgroundDraw bi
    NEXT bi

    'Call out to any custom screen drawing
    __GX_CustomDrawEvent GXEVENT_DRAWBG

    ' Draw the map tiles
    GXMapDraw

    'Call out to any custom screen drawing
    __GX_CustomDrawEvent GXEVENT_DRAWMAP

    ' Draw the entities
    DIM e AS GXEntity
    FOR ei = 1 TO gx_entity_count
        e = gx_entities(ei)
        IF e.screen = 0 THEN
            IF __GX_RectCollide(e.x, e.y, e.width, e.height, GXSceneX, GXSceneY, GXSceneWidth, GXSceneHeight) THEN
                GXEntityDraw e
            END IF
        END IF
        IF e.animate > 0 THEN
            IF frame MOD (gx_framerate / e.animate) = 0 THEN
                GXEntityFrameNext ei
            END IF
        END IF
    NEXT ei

    ' Draw the screen entities which should appear on top of the other game entities
    ' and have a fixed position
    FOR ei2 = 1 TO gx_entity_count
        IF gx_entities(ei2).screen = 1 THEN
            GXEntityDraw gx_entities(ei2)
        END IF
    NEXT ei2

    'Call out to any custom screen drawing
    __GX_CustomDrawEvent GXEVENT_DRAWSCREEN

    ' Copy the background image to the screen
    __GX_CustomEvent GXEVENT_PAINTBEFORE
    _DONTBLEND
    _PUTIMAGE , gx_scene.image
    _BLEND
    __GX_CustomEvent GXEVENT_PAINTAFTER

END SUB

SUB GXSceneMove (dx AS LONG, dy AS LONG)
    gx_scene.x = gx_scene.x + dx
    gx_scene.y = gx_scene.y + dy
END SUB

SUB GXScenePos (x AS LONG, y AS LONG)
    gx_scene.x = x
    gx_scene.y = y
END SUB

FUNCTION GXSceneX
    GXSceneX = gx_scene.x
END FUNCTION

FUNCTION GXSceneY
    GXSceneY = gx_scene.y
END FUNCTION

FUNCTION GXSceneWidth
    GXSceneWidth = gx_scene.width
END FUNCTION

FUNCTION GXSceneHeight
    GXSceneHeight = gx_scene.height
END FUNCTION

FUNCTION GXSceneColumns
    GXSceneColumns = gx_scene.columns
END FUNCTION

FUNCTION GXSceneRows
    GXSceneRows = gx_scene.rows
END FUNCTION

SUB GXSceneStart
    gx_ticks = 0
    gx_scene.active = 1

    DO
        _LIMIT gx_framerate
        gx_ticks = gx_ticks + 1

        ' Call custom game update logic
        __GX_CustomEvent GXEVENT_UPDATE

        ' Perform any movement for registered player entities
        DIM i AS INTEGER
        FOR i = 1 TO gx_player_count
            __GX_PlayerAction i
        NEXT i

        ' Check for entity movement and collisions
        ' TODO: filter out non-moving entities
        __GX_SceneMoveEntities

        ' Perform any auto-scene moves
        DIM sx AS LONG, sy AS LONG
        IF gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER OR _
           gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X THEN
            sx = (GXEntityX(gx_scene.followEntity) + GXEntityWidth(gx_scene.followEntity) / 2) - GXSceneWidth / 2
            GXScenePos sx, GXSceneY
        END IF
        IF gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER OR _
           gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_Y THEN
            sy = (GXEntityY(gx_scene.followEntity) + GXEntityHeight(gx_scene.followEntity) / 2) - GXSceneHeight / 2
            GXScenePos GXSceneX, sy
        END IF
        'IF gx_player_count > 0 THEN
        '    DIM player AS GXPlayer
        '    player = gx_players(1)
        '    IF gx_entities(player.eid).applyGravity THEN ' this is temporary until the above TODO is implemented
        '        IF GXEntityX(player.eid) > GXSceneX + GXSceneWidth / 2 AND GXSceneX < GXMapColumns * GXTilesetWidth - GXSceneWidth THEN
        ''GXSceneMove 1, 0
        '            GXScenePos GXEntityX(player.eid) - GXSceneWidth / 2, 0
        '        END IF
        '    END IF
        'END IF
        ' Check the scene move constraints
        IF gx_scene.constrainMode = GXSCENE_CONSTRAIN_TO_MAP THEN
            DIM mwidth AS INTEGER
            DIM mheight AS INTEGER
            mwidth = GXMapColumns * GXTilesetWidth
            mheight = GXMapRows * GXTilesetHeight
            sx = GXSceneX
            IF sx < 0 THEN
                sx = 0
            ELSEIF sx + GXSceneWidth > mwidth THEN
                sx = mwidth - GXSceneWidth
                IF sx < 0 THEN sx = 0
            END IF

            sy = GXSceneY
            'PRINT "GXSceneHeight:"; GXSceneHeight
            'PRINT "sy-before:"; sy
            IF sy < 0 THEN
                sy = 0
            ELSEIF sy + GXSceneHeight > mheight THEN
                sy = mheight - GXSceneHeight
                IF sy < 0 THEN sy = 0
            END IF
            'PRINT "sy-after:"; sy
            '_DISPLAY
            '_DELAY 2
            GXScenePos sx, sy
        END IF

        'Redraw the scene
        GXSceneDraw
        _DISPLAY
    LOOP WHILE gx_scene.active
END SUB

' TODO: revisit "follow" wording.
SUB GXSceneFollowEntity (eid AS INTEGER, mode AS INTEGER)
    gx_scene.followEntity = eid
    gx_scene.followMode = mode
END SUB

SUB GXSceneConstrain (mode AS INTEGER)
    gx_scene.constrainMode = mode
END SUB

SUB __GX_SceneMoveEntities
    DIM frameFactor AS DOUBLE
    frameFactor = 1 / gx_framerate

    'DIM e AS GXEntity
    DIM eid AS INTEGER, ci AS INTEGER
    REDIM centities(0) AS INTEGER
    DIM ecount AS INTEGER
    FOR eid = 1 TO gx_entity_count
        'e = gx_entities(eid)
        IF gx_entities(eid).screen = 0 THEN
            ' Check for entity collisions
            ecount = __GX_EntityCollision(eid, 0, 0, centities())
            FOR ci = 1 TO ecount
                DIM ee AS GXEvent
                ee.event = GXEVENT_COLLISION_ENTITY
                ee.entity = eid
                ee.collisionEntity = centities(ci)
                GXOnGameEvent ee
            NEXT ci

            ' Move the entity
            IF gx_entities(eid).applyGravity = 1 THEN
                DIM tpos AS GXPosition
                DIM centity AS INTEGER
                DIM tmove AS INTEGER
                tmove = __GX_EntityTestMove(eid, 0, 1, tpos, centity)
                centity = 0
                IF (gx_entities(eid).jumping = 1 AND gx_entities(eid).vy < 0) OR tmove THEN
                    IF gx_entities(eid).jumpstart = 0 THEN
                        gx_entities(eid).jumpstart = GXTicks - 45
                    ELSE
                        ' calculate the number of seconds since the gravity started being applied
                        DIM t
                        t = (GXTicks - gx_entities(eid).jumpstart) / GXFrameRate
                        gx_entities(eid).vy = gx_entities(eid).vy + 9.8 * t ^ 2 / 2
                    END IF
                    'ELSE
                END IF

                ' test to see if we have hit the block or entity above or below
                tmove = __GX_EntityTestMove(eid, 0, gx_entities(eid).vy * frameFactor, tpos, centity)
                IF tmove = 0 THEN
                    IF gx_entities(eid).vy < 0 THEN

                        ' if we hit a block above, then reverse the current velocity
                        ' and make sure the entity does not move above the collision offset
                        gx_entities(eid).vy = -gx_entities(eid).vy
                        '                    gx_entities(eid).jumpspeed = 0
                        IF (centity) THEN
                            gx_entities(eid).y = GXEntityY(centity) + GXEntityHeight(centity) - GXEntityCollisionOffsetTop(eid)
                        ELSE
                            gx_entities(eid).y = GXTilesetHeight * (tpos.y + 1) - GXEntityCollisionOffsetTop(eid)
                        END IF

                    ELSEIF gx_entities(eid).vy > 0 THEN

                        ' if we hit a block below, then zero out the jump speed and end the "fall"
                        ' and make sure the entity does not move below the collision offset
                        gx_entities(eid).jumpstart = 0
                        gx_entities(eid).jumping = 0
                        gx_entities(eid).vy = 0

                        IF (centity) THEN
                            gx_entities(eid).y = GXEntityY(centity) - GXEntityHeight(eid)
                        ELSE
                            gx_entities(eid).y = GXTilesetHeight * (tpos.y) - (GXEntityHeight(eid) - GXEntityCollisionOffsetBottom(eid))
                        END IF
                    END IF

                    'END IF
                END IF

            END IF ' end if apply gravity

            ' apply the move vector to the entity's position
            IF gx_entities(eid).vx THEN
                gx_entities(eid).x = gx_entities(eid).x + gx_entities(eid).vx * frameFactor
            END IF
            IF gx_entities(eid).vy THEN
                gx_entities(eid).y = gx_entities(eid).y + gx_entities(eid).vy * frameFactor
            END IF
        END IF
    NEXT eid
END SUB

FUNCTION GXTicks
    GXTicks = gx_ticks
END FUNCTION

SUB GXSceneStop
    gx_scene.active = 0
END SUB



SUB GXMapCreate (columns AS INTEGER, rows AS INTEGER)
    gx_map.columns = columns
    gx_map.rows = rows

    REDIM gx_map(gx_map.rows, gx_map.columns) AS GXMapTile
END SUB

FUNCTION GXMapColumns
    GXMapColumns = gx_map.columns
END FUNCTION

FUNCTION GXMapRows
    GXMapRows = gx_map.rows
END FUNCTION

SUB GXMapDraw
    IF gx_map.rows < 1 THEN EXIT SUB

    DIM tpos AS GXPosition
    DIM srow, scol, row, col, layer AS LONG
    DIM xoffset, yoffset, pcol, prow AS LONG
    DIM t AS INTEGER
    DIM rowOffset AS LONG
    DIM colOffset AS LONG

    xoffset = gx_scene.x MOD gx_tileset.width
    pcol = FIX(gx_scene.x / gx_tileset.width)
    yoffset = gx_scene.y MOD gx_tileset.height
    prow = FIX(gx_scene.y / gx_tileset.height)

    srow = 0
    rowOffset = 0
    FOR row = prow TO prow + GXSceneRows + 1
        scol = 0
        colOffset = 0
        IF GXMapIsometric AND row MOD 2 = 1 THEN colOffset = GXTilesetWidth / 2
        FOR col = pcol TO pcol + GXSceneColumns + 1
            FOR layer = 1 TO GXMapTileDepth(col, row)
                t = GXMapTile(col, row, layer)
                GX_TilesetGetPos t, tpos
                GXSpriteDraw gx_tileset.image, scol * gx_tileset.width - xoffset + colOffset, srow * gx_tileset.height - yoffset - rowOffset, tpos.y, tpos.x, gx_tileset.width, gx_tileset.height, gx_scene.image
            NEXT layer
            scol = scol + 1
        NEXT col
        srow = srow + 1
        IF GXMapIsometric THEN rowOffset = rowOffset + (GXTilesetHeight * .75)
    NEXT row
END SUB

FUNCTION GXMapTile (col AS INTEGER, row AS INTEGER, layer AS INTEGER)
    IF col < 0 OR col >= gx_map.columns OR row < 0 OR row >= gx_map.rows THEN
        GXMapTile = 0
    ELSE
        DIM mtile AS GXMapTile
        mtile = gx_map(row, col)
        IF layer = 1 THEN GXMapTile = mtile.layer1
        IF layer = 2 THEN GXMapTile = mtile.layer2
        IF layer = 3 THEN GXMapTile = mtile.layer3
    END IF
END FUNCTION

FUNCTION GXMapTileDepth (col AS INTEGER, row AS INTEGER)
    IF col < 0 OR col >= gx_map.columns OR row < 0 OR row >= gx_map.rows THEN
        GXMapTileDepth = 0
    ELSE
        GXMapTileDepth = gx_map(row, col).depth
    END IF
END FUNCTION

SUB GXMapTileAdd (tile AS INTEGER, col AS INTEGER, row AS INTEGER)
    DIM layer AS INTEGER
    IF (col >= 0 AND col <= gx_map.columns AND row >= 0 AND row < gx_map.rows) THEN
        layer = gx_map(row, col).depth + 1
        IF layer < 4 THEN
            gx_map(row, col).depth = layer
            IF layer = 1 THEN
                gx_map(row, col).layer1 = tile
            ELSEIF layer = 2 THEN
                gx_map(row, col).layer2 = tile
            ELSEIF layer = 3 THEN
                gx_map(row, col).layer3 = tile
            END IF
        END IF
    END IF
END SUB

SUB GXMapTileRemove (col AS INTEGER, row AS INTEGER)
    DIM depth AS INTEGER
    depth = gx_map(row, col).depth
    IF depth > 0 THEN
        gx_map(row, col).depth = depth - 1
    END IF
END SUB

SUB GXMapTileClear (col AS INTEGER, row AS INTEGER)
    DIM mt AS GXMapTile
    gx_map(row, col) = mt
END SUB


SUB GXMapSave (filename AS STRING)
    DIM version AS INTEGER
    DIM col AS INTEGER
    DIM row AS INTEGER
    DIM layer AS INTEGER
    DIM tile AS INTEGER
    DIM depth AS INTEGER

    version = 1

    ' TODO: check to see if the tileset image has been removed before deleting
    '       the original file
    IF _FILEEXISTS(filename) THEN
        KILL filename
    END IF
    OPEN filename FOR BINARY AS #1

    ' Save the map version
    PUT #1, , version

    ' Save the map tile data
    PUT #1, , gx_map.columns
    PUT #1, , gx_map.rows

    FOR row = 0 TO gx_map.rows - 1
        FOR col = 0 TO gx_map.columns - 1
            depth = GXMapTileDepth(col, row)
            PUT #1, , depth
            IF depth > 0 THEN
                FOR layer = 1 TO depth
                    tile = GXMapTile(col, row, layer)
                    PUT #1, , tile
                NEXT layer
            END IF
        NEXT col
    NEXT row

    ' Save the tilemap information
    __GX_WriteString gx_tileset.filename
    PUT #1, , gx_tileset.width
    PUT #1, , gx_tileset.height

    ' Save the tileset image data
    DIM tsize AS LONG
    OPEN gx_tileset.filename FOR BINARY AS #2
    tsize = LOF(2)
    PUT #1, , tsize

    DIM bytes(tsize) AS _UNSIGNED _BYTE
    GET #2, , bytes()
    PUT #1, , bytes()
    CLOSE #2

    CLOSE #1
END SUB

' Load the map
SUB GXMapLoad (filename AS STRING)
    gx_map_loading = 1

    OPEN filename FOR BINARY AS #1

    ' Read the version
    DIM version AS INTEGER
    GET #1, 1, version

    ' For backwards compatibility, add new versions of the
    ' load function to continue to support older maps
    SELECT CASE version
        CASE 1: __GX_MapLoadV1 filename
    END SELECT

    CLOSE #1

    gx_map_loading = 0
END SUB

' Load a version 1 map
SUB __GX_MapLoadV1 (filename AS STRING)
    DIM col AS INTEGER
    DIM row AS INTEGER
    DIM layer AS INTEGER
    DIM depth AS INTEGER
    DIM tile AS INTEGER

    GET #1, , gx_map.columns
    GET #1, , gx_map.rows

    REDIM gx_map(gx_map.rows, gx_map.columns) AS GXMapTile

    FOR row = 0 TO gx_map.rows - 1
        FOR col = 0 TO gx_map.columns - 1
            GET #1, , depth
            IF depth > 0 THEN
                FOR layer = 1 TO depth
                    GET #1, , tile
                    GXMapTileAdd tile, col, row
                NEXT layer
            END IF
        NEXT col
    NEXT row

    ' Read the tileset information
    DIM tilesetFilename AS STRING
    DIM tilewidth AS INTEGER
    DIM tileheight AS INTEGER
    tilesetFilename = __GX_ReadString ' original tileset filename
    GET #1, , tilewidth
    GET #1, , tileheight

    ' If the map has an embedded tileset image, save it to a temp file location
    DIM tsize AS LONG
    GET #1, , tsize
    IF NOT EOF(1) THEN
        DIM tmpfile AS STRING
        'DIM i AS LONG
        'DIM b AS _UNSIGNED _BYTE
        DIM bytes(tsize) AS _UNSIGNED _BYTE
        tmpfile = __GXFS_RemoveFileExtension(__GXFS_GetFilename(filename)) + ".ts1"
        IF NOT _DIREXISTS("./tmp") THEN MKDIR ("./tmp")
        tilesetFilename = "./tmp/" + tmpfile
        GET #1, , bytes()
        OPEN tilesetFilename FOR BINARY AS #2
        PUT #2, , bytes()
        CLOSE #2
        GXTilesetCreate tilesetFilename, tilewidth, tileheight
        'KILL tilesetFilename
    ELSE
        GXTilesetCreate tilesetFilename, tilewidth, tileheight
    END IF

END SUB

FUNCTION GXMapIsometric
    GXMapIsometric = gx_map.isometric
END FUNCTION

SUB GXMapIsometric (iso AS INTEGER)
    gx_map.isometric = iso
    __GX_UpdateSceneSize
END SUB

SUB __GX_UpdateSceneSize
    IF gx_tileset.width < 1 OR gx_tileset.height < 1 THEN EXIT SUB
    IF GXMapIsometric THEN
        gx_scene.columns = FIX(gx_scene.width / gx_tileset.width)
        gx_scene.rows = FIX(gx_scene.height / (gx_tileset.height * .25))
    ELSE
        gx_scene.columns = FIX(gx_scene.width / gx_tileset.width)
        gx_scene.rows = FIX(gx_scene.height / gx_tileset.height)
    END IF
END SUB

SUB __GX_WriteString (s AS STRING)
    DIM l AS INTEGER
    l = LEN(s)
    PUT #1, , l
    PUT #1, , s
END SUB

FUNCTION __GX_ReadString$
    DIM s AS STRING
    DIM l AS INTEGER
    DIM i AS INTEGER
    DIM b AS _UNSIGNED _BYTE
    GET #1, , l
    FOR i = 1 TO l
        GET #1, , b
        s = s + CHR$(b)
    NEXT i
    __GX_ReadString = s
END FUNCTION


SUB GXSpriteDraw (i AS LONG, x AS LONG, y AS LONG, seq AS INTEGER, frame AS INTEGER, swidth AS INTEGER, sheight AS INTEGER, imgdest AS LONG)
    DIM xoffset, yoffset
    xoffset = (frame - 1) * swidth
    yoffset = (seq - 1) * sheight
    IF imgdest THEN
        _PUTIMAGE (x, y), i, imgdest, (xoffset, yoffset)-(xoffset + (swidth - 1), yoffset + (sheight - 1))
    ELSE
        _PUTIMAGE (x, y), i, , (xoffset, yoffset)-(xoffset + (swidth - 1), yoffset + (sheight - 1))
    END IF
END SUB


SUB GXTilesetCreate (tilesetFilename AS STRING, tileWidth AS INTEGER, tileHeight AS INTEGER)
    gx_tileset.filename = tilesetFilename
    gx_tileset.width = tileWidth
    gx_tileset.height = tileHeight

    DIM tswidth, tsheight
    gx_tileset.image = GXImageLoad(tilesetFilename)
    tswidth = _WIDTH(gx_tileset.image)
    tsheight = _HEIGHT(gx_tileset.image)

    gx_tileset.columns = tswidth / gx_tileset.width
    gx_tileset.rows = tsheight / gx_tileset.height

    gx_scene.columns = FIX(gx_scene.width / gx_tileset.width)
    gx_scene.rows = FIX(gx_scene.height / gx_tileset.height)
END SUB


SUB GX_TilesetGetPos (tilenum AS INTEGER, p AS GXPosition)
    IF gx_tileset.columns = 0 THEN
        p.x = 0
        p.y = 0
    ELSE
        p.y = FIX(tilenum / gx_tileset.columns)
        p.y = p.y + 1
        p.x = tilenum MOD gx_tileset.columns + 1
    END IF
END SUB

FUNCTION GXTilesetWidth
    GXTilesetWidth = gx_tileset.width
END FUNCTION

FUNCTION GXTilesetHeight
    GXTilesetHeight = gx_tileset.height
END FUNCTION

FUNCTION GXTilesetColumns
    GXTilesetColumns = gx_tileset.columns
END FUNCTION

FUNCTION GXTilesetRows
    GXTilesetRows = gx_tileset.rows
END FUNCTION

FUNCTION GXTilesetFilename$
    GXTilesetFilename = gx_tileset.filename
END FUNCTION

FUNCTION GXTilesetImage
    GXTilesetImage = gx_tileset.image
END FUNCTION


' File System Utility Methods
' ----------------------------------------------------------------------------
FUNCTION __GXFS_GetFilename$ (filepath AS STRING)
    DIM s AS STRING, i AS INTEGER
    s = filepath
    s = __GXSTR_Replace(s, "\", "/")
    i = _INSTRREV(s, "/")
    s = MID$(s, i + 1)
    __GXFS_GetFilename = s
END FUNCTION

FUNCTION __GXFS_GetParentPath$ (filepath AS STRING)
    DIM s AS STRING, i AS INTEGER
    s = filepath
    s = __GXSTR_Replace(s, "\", "/")
    i = _INSTRREV(s, "/")
    s = MID$(s, 1, i - 1)
    s = __GXSTR_Replace(s, "/", __GXFS_PathSeparator)
    'IF __GXFS_IsDriveLetter(s) THEN s = s + __GXFS_PathSeparator
    IF s = "" THEN s = __GXFS_PathSeparator
    __GXFS_GetParentPath = s
END FUNCTION

FUNCTION __GXFS_GetFileExtension$ (filename AS STRING)
    DIM i AS INTEGER
    'i = __GX_StrLastIndexOf(filename, ".")
    i = _INSTRREV(filename, ".")
    __GXFS_GetFileExtension = MID$(filename, i + 1)
END FUNCTION

FUNCTION __GXFS_RemoveFileExtension$ (filename AS STRING)
    DIM i AS INTEGER
    i = _INSTRREV(filename, ".")
    __GXFS_RemoveFileExtension = MID$(filename, 1, i - 1)
END FUNCTION

FUNCTION __GXFS_IsDriveLetter (path AS STRING)
    IF LEN(path) = 2 AND RIGHT$(path, 1) = ":" THEN
        __GXFS_IsDriveLetter = GX_TRUE
    ELSE
        __GXFS_IsDriveLetter = GX_FALSE
    END IF
END FUNCTION

FUNCTION __GXFS_DriveList (drives() AS STRING)
    $IF WINDOWS THEN
        DIM text AS STRING
        DIM tmpfile AS STRING
        tmpfile = "__drivelist"

        ' Remove the temp file, if it exists
        IF _FILEEXISTS(tmpfile) THEN KILL tmpfile

        ' Print the drive list to a file
        SHELL _HIDE "cmd /c " + CHR$(34) + "fsutil fsinfo drives > " + tmpfile + CHR$(34)

        DIM count AS INTEGER
        count = 0
        IF _FILEEXISTS(tmpfile) THEN
            OPEN tmpfile FOR BINARY AS #1
            text = SPACE$(LOF(1))
            GET #1, , text
            CLOSE #1
            KILL tmpfile
            text = __GXSTR_Replace(text, "Drives: ", "")
            text = __GXSTR_Replace(text, GX_CRLF, "")
            text = __GXSTR_Replace(text, "\", "")
            count = __GXSTR_Split(text, " ", drives())
        END IF

        __GXFS_DriveList = count
    $ELSE
        __GXFS_DriveList = 0
    $END IF
END FUNCTION

FUNCTION __GXFS_PathSeparator$ ()
    $IF WINDOWS THEN
        __GXFS_PathSeparator = "\"
    $ELSE
        __GXFS_PathSeparator = "/"
    $END IF
END FUNCTION

FUNCTION __GXFS_DirList (path AS STRING, dirmode AS INTEGER, filenames() AS STRING)
    DIM cmd AS STRING
    DIM tmpfile AS STRING
    tmpfile = "__filelist"

    ' Remove the temp file, if it exists
    IF _FILEEXISTS(tmpfile) THEN KILL tmpfile

    ' Determine the OS-specific directory command
    $IF WINDOWS THEN
        IF dirmode THEN
            cmd = "dir /b /ad " + CHR$(34) + path + CHR$(34) + " > " + tmpfile
        ELSE
            cmd = "dir /b /a-d " + CHR$(34) + path + CHR$(34) + " > " + tmpfile
        END IF
    $ELSE
        IF dirmode THEN
        cmd = "find " + CHR$(34) + path + CHR$(34) + " -maxdepth 1 -type d | sed '1d' | sed 's/.*\///g' > " + tmpfile
        ELSE
        cmd = "ls -p " + CHR$(34) + path + CHR$(34) + " | grep -v / > " + tmpfile
        END IF
    $END IF

    IF cmd <> "" THEN
        SHELL _HIDE cmd

        DIM filename AS STRING
        DIM fcount AS INTEGER
        fcount = 0
        IF _FILEEXISTS(tmpfile) THEN
            ' Read each line of the temp file into the result array
            OPEN tmpfile FOR INPUT AS #1
            DO UNTIL EOF(1)
                LINE INPUT #1, filename
                IF dirmode OR filename <> tmpfile THEN
                    fcount = fcount + 1
                    REDIM _PRESERVE filenames(fcount) AS STRING
                    filenames(fcount) = filename
                END IF
            LOOP
            CLOSE #1
            ' Remove the temp file
            KILL tmpfile
        END IF
    END IF

    ' Return the number of items in the result array
    __GXFS_DirList = fcount
END FUNCTION
' ----------------------------------------------------------------------------



' String Utility Methods
' ----------------------------------------------------------------------------
FUNCTION __GXSTR_Replace$ (s AS STRING, searchString AS STRING, newString AS STRING)
    DIM ns AS STRING
    DIM i AS INTEGER

    DIM slen AS INTEGER
    slen = LEN(searchString)

    FOR i = 1 TO LEN(s) '- slen + 1
        IF MID$(s, i, slen) = searchString THEN
            ns = ns + newString
            i = i + slen - 1
        ELSE
            ns = ns + MID$(s, i, 1)
        END IF
    NEXT i

    __GXSTR_Replace = ns
END FUNCTION

FUNCTION __GXSTR_Split (sourceString AS STRING, delimiter AS STRING, results() AS STRING)
    ' Modified version of:
    ' https://www.qb64.org/forum/index.php?topic=1073.msg102711#msg102711
    DIM cstr AS STRING, p AS LONG, curpos AS LONG, arrpos AS LONG, dpos AS LONG

    ' Make a copy of the source string
    cstr = sourceString

    ' Special case if the delimiter is space, remove all excess space
    IF delimiter = " " THEN
        cstr = RTRIM$(LTRIM$(cstr))
        p = INSTR(cstr, "  ")
        WHILE p > 0
            cstr = MID$(cstr, 1, p - 1) + MID$(cstr, p + 1)
            p = INSTR(cstr, "  ")
        WEND
    END IF
    curpos = 1
    arrpos = 0
    dpos = INSTR(curpos, cstr, delimiter)
    DO UNTIL dpos = 0
        arrpos = arrpos + 1
        REDIM _PRESERVE results(arrpos) AS STRING
        results(arrpos) = MID$(cstr, curpos, dpos - curpos)
        curpos = dpos + LEN(delimiter)
        dpos = INSTR(curpos, cstr, delimiter)
    LOOP
    arrpos = arrpos + 1
    REDIM _PRESERVE results(arrpos) AS STRING
    results(arrpos) = MID$(cstr, curpos)

    __GXSTR_Split = arrpos
END FUNCTION
' ----------------------------------------------------------------------------


FUNCTION __GX_EntityCollide (eid1, eid2)
    __GX_EntityCollide = __GX_RectCollide(GXEntityX(eid1), GXEntityY(eid1), GXEntityWidth(eid1), GXEntityHeight(eid1), GXEntityX(eid2), GXEntityY(eid2), GXEntityWidth(eid2), GXEntityHeight(eid2))
END FUNCTION

FUNCTION __GX_RectCollide (r1x1%, r1y1%, r1w%, r1h%, r2x1%, r2y1%, r2w%, r2h%)

    DIM r1x2%, r1y2%, r2x2%, r2y2%
    r1x2% = r1x1% + r1w%
    r1y2% = r1y1% + r1h%
    r2x2% = r2x1% + r2w%
    r2y2% = r2y1% + r2h%

    __GX_RectCollide = 0
    IF r1x2% >= r2x1% THEN
        IF r1x1% <= r2x2% THEN
            IF r1y2% >= r2y1% THEN
                IF r1y1% <= r2y2% THEN
                    __GX_RectCollide = 1
                END IF
            END IF
        END IF
    END IF

END FUNCTION

FUNCTION GXFontCreate (filename AS STRING, charWidth AS INTEGER, charHeight AS INTEGER, charref AS STRING)
    gx_font_count = gx_font_count + 1
    REDIM _PRESERVE gx_fonts(gx_font_count) AS GXFont
    REDIM _PRESERVE gx_font_charmap(256, gx_font_count) AS GXPosition

    ' Create a new game entity
    gx_fonts(gx_font_count).eid = GXEntityCreate(filename, charWidth, charHeight, 1)
    ' Hide the entity as we will not be displaying it as a normal sprite
    GXEntityHide gx_fonts(gx_font_count).eid

    ' map the character codes to the image location
    DIM cx AS INTEGER, cy AS INTEGER, i AS INTEGER, a AS INTEGER
    cx = 1
    cy = 1
    FOR i = 1 TO LEN(charref)
        a = ASC(MID$(charref, i, 1))
        IF a = 10 THEN
            cx = 1
            cy = cy + 1
        ELSE
            IF a >= 33 AND a <= 256 THEN
                gx_font_charmap(a, gx_font_count).x = cx
                gx_font_charmap(a, gx_font_count).y = cy
            END IF
            cx = cx + 1
        END IF
    NEXT i

    GXFontCreate = gx_font_count
END FUNCTION

FUNCTION GXFontCharSpacing (fid AS LONG)
    GXFontCharSpacing = gx_fonts(fid).charSpacing
END FUNCTION

SUB GXFontCharSpacing (fid AS LONG, charSpacing AS INTEGER)
    gx_fonts(fid).charSpacing = charSpacing
END SUB

FUNCTION GXFontLineSpacing (fid AS LONG)
    GXFontLineSpacing = gx_fonts(fid).lineSpacing
END FUNCTION

SUB GXFontLineSpacing (fid AS LONG, lineSpacing AS INTEGER)
    gx_fonts(fid).lineSpacing = lineSpacing
END SUB

SUB GXBlitString (fid AS INTEGER, sx AS LONG, sy AS LONG, s AS STRING)
    DIM i AS INTEGER
    DIM a AS INTEGER
    DIM c AS STRING
    DIM cpos AS GXPosition
    DIM x AS LONG: x = sx
    DIM y AS LONG: y = sy
    DIM font AS GXFont: font = gx_fonts(fid)
    DIM e AS GXEntity: e = gx_entities(font.eid)

    FOR i = 1 TO LEN(s)
        c = MID$(s, i, 1)
        a = ASC(c)
        IF a = 10 THEN ' Line feed, move down to the next line
            x = sx
            y = y + e.height + font.lineSpacing
        ELSEIF NOT a = 13 THEN ' Ignore Carriage Return
            IF NOT a = 32 THEN ' Space character, nothing to draw
                cpos = gx_font_charmap(a, fid)
                GXSpriteDraw e.image, x, y, cpos.y, cpos.x, e.width, e.height, 0
            END IF
            x = x + e.width + font.charSpacing
        END IF
    NEXT i
END SUB

FUNCTION __GX_EntityTestMove (entity AS INTEGER, mx AS LONG, my AS LONG, tpos AS GXPosition, collisionEntity AS INTEGER)
    tpos.x = -1
    tpos.y = -1
    'IF nocollision THEN GX_EntityTestMove = 1: EXIT FUNCTION

    DIM tcount AS INTEGER
    REDIM tiles(0) AS GXPosition
    __GX_EntityCollisionTiles entity, mx, my, tiles(), tcount


    DIM move AS INTEGER
    move = 1

    ' Test for tile collision
    DIM i AS INTEGER, j AS INTEGER
    DIM tile AS INTEGER
    FOR i = 0 TO tcount - 1
        FOR j = 1 TO GXMapTileDepth(tiles(i).x, tiles(i).y)
            tile = GXMapTile(tiles(i).x, tiles(i).y, j)
            DIM e AS GXEvent
            e.entity = entity
            e.event = GXEVENT_COLLISION_TILE
            e.collisionTile = tile
            GXOnGameEvent e
            IF e.collisionResult THEN
                move = 0
                tpos = tiles(i)
            END IF
        NEXT j
    NEXT i

    ' Test for entity collision
    DIM entities(0) AS INTEGER
    DIM ecount AS INTEGER
    ecount = __GX_EntityCollision(entity, mx, my, entities())
    FOR i = 1 TO ecount
        DIM ee AS GXEvent
        ee.entity = entity
        ee.event = GXEVENT_COLLISION_ENTITY
        ee.collisionEntity = entities(i)
        GXOnGameEvent ee
        IF ee.collisionResult THEN
            move = 0
            collisionEntity = entities(i)
        END IF
    NEXT i

    __GX_EntityTestMove = move
END FUNCTION

FUNCTION __GX_EntityCollision (eid AS INTEGER, movex AS INTEGER, movey AS INTEGER, entities() AS INTEGER) ', ecount AS INTEGER)
    DIM ecount AS INTEGER
    ecount = 0

    DIM i AS INTEGER
    FOR i = 1 TO gx_entity_count
        IF i <> eid THEN
            ' TODO: only include entities that should be considered (e.g. visible, non-screen-level)
            IF __GX_RectCollide(GXEntityX(eid) + GXEntityCollisionOffsetLeft(eid) + movex, _
               GXEntityY(eid) + GXEntityCollisionOffsetTop(eid) + movey, _
               GXEntityWidth(eid) - GXEntityCollisionOffsetLeft(eid) - GXEntityCollisionOffsetRight(eid), _
               GXEntityHeight(eid) - GXEntityCollisionOffsetTop(eid) - GXEntityCollisionOffsetBottom(eid), _
               GXEntityX(i) + GXEntityCollisionOffsetLeft(i), _
               GXEntityY(i) + GXEntityCollisionOffsetTop(i), _
               GXEntityWidth(i) - GXEntityCollisionOffsetLeft(i) - GXEntityCollisionOffsetRight(i), _
               GXEntityHeight(i) - GXEntityCollisionOffsetTop(i) - GXEntityCollisionOffsetBottom(i)) THEN
                ecount = ecount + 1
                REDIM _PRESERVE entities(ecount) AS INTEGER
                entities(ecount) = i
            END IF
        END IF
    NEXT i

    __GX_EntityCollision = ecount
END FUNCTION

SUB __GX_EntityCollisionTiles (entity AS INTEGER, movex AS INTEGER, movey AS INTEGER, tiles() AS GXPosition, tcount AS INTEGER)
    DIM tx AS INTEGER, ty AS INTEGER
    DIM tx0 AS INTEGER, txn AS INTEGER
    DIM ty0 AS INTEGER, tyn AS INTEGER
    DIM x AS INTEGER, y AS INTEGER, i AS INTEGER

    IF movex <> 0 THEN
        DIM startx AS INTEGER
        startx = -1 + GXEntityCollisionOffsetLeft(entity) 'cx
        IF movex > 0 THEN startx = GXEntityWidth(entity) + movex - GXEntityCollisionOffsetRight(entity) 'cx2
        tx = FIX((GXEntityX(entity) + startx) / GXTilesetWidth)

        ' This is a real brute force way to find the intersecting tiles.
        ' We're basically testing every pixel along the edge of the entity's
        ' collision rect and incrementing the collision tile count.
        ' With a bit more math I'm sure we could avoid some extra loops here.
        tcount = 0
        ty0 = 0
        FOR y = GXEntityY(entity) + GXEntityCollisionOffsetTop(entity) TO GXEntityY(entity) + GXEntityHeight(entity) - 1 - GXEntityCollisionOffsetBottom(entity)
            ty = FIX(y / GXTilesetHeight)
            IF tcount = 0 THEN ty0 = ty
            IF NOT ty = tyn THEN
                tcount = tcount + 1
            END IF
            tyn = ty
        NEXT y

        ' Add the range of detected tile positions to the return list
        REDIM tiles(tcount) AS GXPosition
        i = 0
        FOR ty = ty0 TO tyn
            tiles(i).x = tx
            tiles(i).y = ty
            i = i + 1
        NEXT ty
    END IF

    IF movey <> 0 THEN
        DIM starty AS INTEGER
        starty = -1 + GXEntityCollisionOffsetTop(entity) 'cy
        IF movey > 0 THEN starty = GXEntityHeight(entity) + movey - GXEntityCollisionOffsetBottom(entity) 'cy2
        ty = FIX((GXEntityY(entity) + starty) / GXTilesetHeight)

        ' This is a real brute force way to find the intersecting tiles.
        ' We're basically testing every pixel along the edge of the entity's
        ' collision rect and incrementing the collision tile count.
        ' With a bit more math I'm sure we could avoid some extra loops here.
        tcount = 0
        tx0 = 0
        FOR x = GXEntityX(entity) + GXEntityCollisionOffsetLeft(entity) TO GXEntityX(entity) + GXEntityWidth(entity) - 1 - GXEntityCollisionOffsetRight(entity)
            tx = FIX(x / GXTilesetWidth)
            IF tcount = 0 THEN tx0 = tx
            IF NOT tx = txn THEN
                tcount = tcount + 1
            END IF
            txn = tx
        NEXT x


        REDIM tiles(tcount) AS GXPosition
        i = 0
        FOR tx = tx0 TO txn
            tiles(i).x = tx
            tiles(i).y = ty
            i = i + 1
        NEXT tx
    END IF
END SUB


FUNCTION GXKeyDown (k AS LONG)
    IF k < 8 THEN
        GXKeyDown = 0
    ELSE
        GXKeyDown = _KEYDOWN(k)

        ' test for letter keys regardless of case
        ' TODO: do the same thing for number keys other dual/mode keys
        IF NOT GXKeyDown AND k >= 97 AND k <= 122 THEN
            k = k - 32
            GXKeyDown = _KEYDOWN(k)
        END IF
    END IF
END FUNCTION


SUB __GX_PlayerAction (pid AS INTEGER)
    DIM tpos AS GXPosition
    'DIM movex AS INTEGER, movey AS INTEGER
    DIM centity AS INTEGER

    DIM player AS GXPlayer
    player = gx_players(pid)

    DIM actionLeft AS GXAction, actionRight AS GXAction, actionUp AS GXAction, actionDown AS GXAction
    DIM actionJump AS GXAction, actionJumpRight AS GXAction, actionJumpLeft AS GXAction
    actionLeft = gx_player_keymap(GXACTION_MOVE_LEFT, pid)
    actionRight = gx_player_keymap(GXACTION_MOVE_RIGHT, pid)
    actionUp = gx_player_keymap(GXACTION_MOVE_UP, pid)
    actionDown = gx_player_keymap(GXACTION_MOVE_DOWN, pid)
    actionJump = gx_player_keymap(GXACTION_JUMP, pid)
    actionJumpRight = gx_player_keymap(GXACTION_JUMP_RIGHT, pid)
    actionJumpLeft = gx_player_keymap(GXACTION_JUMP_LEFT, pid)

    IF GXKeyDown(actionDown.key) THEN
        GXEntityAnimate player.eid, actionDown.animationSeq, actionDown.animationSpeed
        IF __GX_EntityTestMove(player.eid, 0, 1, tpos, centity) THEN
            gx_entities(player.eid).vy = player.walkSpeed
        ELSE
            IF NOT gx_entities(player.eid).applyGravity THEN gx_entities(player.eid).vy = 0
        END IF
        'IF NOT gx_entities(player.eid).applyGravity THEN
        gx_entities(player.eid).vx = 0

    ELSEIF GXKeyDown(actionUp.key) THEN
        GXEntityAnimate player.eid, actionUp.animationSeq, actionUp.animationSpeed
        IF __GX_EntityTestMove(player.eid, 0, -1, tpos, centity) THEN
            gx_entities(player.eid).vy = -player.walkSpeed
        ELSE
            IF NOT gx_entities(player.eid).applyGravity THEN gx_entities(player.eid).vy = 0
        END IF
        'IF gx_entities(player.eid).applyGravity = 0 THEN
        gx_entities(player.eid).vx = 0

    ELSEIF GXKeyDown(actionRight.key) THEN
        GXEntityAnimate player.eid, actionRight.animationSeq, actionRight.animationSpeed
        IF __GX_EntityTestMove(player.eid, 1, 0, tpos, centity) THEN
            gx_entities(player.eid).vx = player.walkSpeed
        ELSE
            gx_entities(player.eid).vx = 0
        END IF
        IF gx_entities(player.eid).applyGravity = 0 THEN gx_entities(player.eid).vy = 0

    ELSEIF GXKeyDown(actionLeft.key) THEN
        GXEntityAnimate player.eid, actionLeft.animationSeq, actionLeft.animationSpeed
        IF __GX_EntityTestMove(player.eid, -1, 0, tpos, centity) THEN
            gx_entities(player.eid).vx = -player.walkSpeed
        ELSE
            gx_entities(player.eid).vx = 0
        END IF
        IF gx_entities(player.eid).applyGravity = 0 THEN gx_entities(player.eid).vy = 0

    ELSE
        GXEntityAnimateOff player.eid
        gx_entities(player.eid).vx = 0
        IF gx_entities(player.eid).applyGravity = 0 THEN
            gx_entities(player.eid).vy = 0
        END IF
    END IF

    IF gx_entities(player.eid).applyGravity = 1 THEN
        IF GXKeyDown(actionJump.key) OR GXKeyDown(actionJumpLeft.key) OR GXKeyDown(actionJumpRight.key) THEN
            IF __GX_EntityTestMove(player.eid, 0, 1, tpos, centity) = 0 THEN
                gx_entities(player.eid).vy = -player.jumpSpeed
                gx_entities(player.eid).jumping = 1
            END IF
        END IF

        IF gx_entities(player.eid).jumping THEN
            IF gx_entities(player.eid).vx < 0 AND actionJumpLeft.animationSeq THEN GXEntityAnimate player.eid, actionJumpLeft.animationSeq, actionJumpLeft.animationSpeed
            IF gx_entities(player.eid).vx > 0 AND actionJumpRight.animationSeq THEN GXEntityAnimate player.eid, actionJumpRight.animationSeq, actionJumpRight.animationSpeed
        END IF
    END IF

END SUB

