$IF GXBI = UNDEFINED THEN
    OPTION _EXPLICIT
    '$include: './gx.bi'

    SUB GXOnGameEvent (e AS GXEvent)
        SELECT CASE e.event
        END SELECT
    END SUB
$END IF
$IF GXBM = UNDEFINED THEN

    ' System Methods
    ' ----------------------------------------------------------------------------
    SUB GXSleep (stime)
        _DELAY stime
    END SUB

    FUNCTION GXMouseX%
        GXMouseX = _MOUSEX / __gx_scene.scaleX
    END FUNCTION

    FUNCTION GXMouseY%
        GXMouseY = _MOUSEY / __gx_scene.scaleY
    END FUNCTION


    ' Sound Methods
    ' ----------------------------------------------------------------------------
    FUNCTION GXSoundLoad (filename AS STRING)
        $IF MACOSX THEN
            ' Sound not currently supported for macosx
        $ELSE
            GXSoundLoad = _SNDOPEN(filename)
        $END IF
    END FUNCTION

    SUB GXSoundPlay (sid AS LONG)
        $IF MACOSX THEN
            ' Sound not currently supported for macosx
        $ELSE
            IF NOT GXSoundMuted THEN _SNDPLAY sid
        $END IF
    END SUB

    SUB GXSoundRepeat (sid AS LONG)
        $IF MACOSX THEN
            ' Sound not currently supported for macosx
        $ELSE
            IF NOT GXSoundMuted THEN _SNDLOOP sid
        $END IF
    END SUB

    SUB GXSoundVolume (sid AS LONG, v)
        $IF MACOSX THEN
            ' Sound not currently supported for macosx
        $ELSE
            _SNDVOL sid, v / 100
        $END IF
    END SUB

    SUB GXSoundPause (sid AS LONG)
        $IF MACOSX THEN
            ' Sound not currently supported for macosx
        $ELSE
            _SNDPAUSE sid
        $END IF
    END SUB

    SUB GXSoundStop (sid AS LONG)
        $IF MACOSX THEN
            ' Sound not currently supported for macosx
        $ELSE
            _SNDSTOP sid
        $END IF
    END SUB

    SUB GXSoundMuted (muted AS INTEGER)
        __gx_sound_muted = muted
        'TODO: maintain a list of loaded sounds so they can all be muted
    END SUB

    FUNCTION GXSoundMuted
        GXSoundMuted = __gx_sound_muted
    END FUNCTION

    SUB GXEntityAnimate (eid AS INTEGER, seq AS INTEGER, a AS INTEGER)
        __gx_entities(eid).animate = a
        __gx_entities(eid).spriteSeq = seq
    END SUB

    SUB GXEntityAnimateStop (eid AS INTEGER)
        __gx_entities(eid).animate = 0
    END SUB

    SUB GXEntityAnimateMode (eid AS INTEGER, mode AS INTEGER)
        __gx_entities(eid).animateMode = mode
    END SUB

    FUNCTION GXEntityAnimateMode (eid AS INTEGER)
        GXEntityAnimateMode = __gx_entities(eid).animateMode
    END FUNCTION

    FUNCTION GXScreenEntityCreate (imageFilename AS STRING, ewidth AS INTEGER, height AS INTEGER, seqFrames AS INTEGER)
        DIM eid AS INTEGER
        eid = GXEntityCreate(imageFilename, ewidth, height, seqFrames)
        __gx_entities(eid).screen = 1
        GXScreenEntityCreate = eid
    END FUNCTION

    FUNCTION GXEntityCreate (imageFilename AS STRING, ewidth AS INTEGER, height AS INTEGER, seqFrames AS INTEGER)
        DIM newent AS GXEntity
        newent.x = 0
        newent.y = 0
        newent.height = height
        newent.width = ewidth
        newent.image = __GX_ImageLoad(imageFilename)
        newent.spriteFrame = 1
        newent.spriteSeq = 1
        newent.seqFrames = seqFrames
        __gx_entity_count = __gx_entity_count + 1
        REDIM _PRESERVE __gx_entities(__gx_entity_count) AS GXEntity
        __gx_entities(__gx_entity_count) = newent
        GXEntityCreate = __gx_entity_count
    END FUNCTION

    SUB GXEntityCreate (imageFilename AS STRING, ewidth AS INTEGER, height AS INTEGER, seqFrames AS INTEGER, uid AS STRING)
        DIM eid AS INTEGER
        eid = GXEntityCreate(imageFilename, ewidth, height, seqFrames)
        __GX uid, eid, GXTYPE_ENTITY
    END SUB

    SUB GXEntityHide (eid AS INTEGER)
        __gx_entities(eid).hidden = 1
    END SUB

    SUB GXEntityShow (eid AS INTEGER)
        __gx_entities(eid).hidden = 0
    END SUB

    SUB __GX_EntityDraw (ent AS GXEntity)
        IF ent.hidden = 1 THEN EXIT SUB
        DIM x, y AS LONG
        IF ent.screen = 1 THEN
            x = ent.x
            y = ent.y
        ELSE
            x = ent.x - GXSceneX
            y = ent.y - GXSceneY
        END IF
        GXSpriteDraw ent.image, x, y, ent.spriteSeq, ent.spriteFrame, ent.width, ent.height, __gx_scene.image
        IF GXDebug THEN __GX_DebugEntity ent, x, y
    END SUB

    SUB GXEntityMove (eid AS INTEGER, x AS LONG, y AS LONG)
        __gx_entities(eid).x = __gx_entities(eid).x + x
        __gx_entities(eid).y = __gx_entities(eid).y + y
    END SUB


    SUB GXEntityPos (eid AS INTEGER, x AS LONG, y AS LONG)
        __gx_entities(eid).x = x
        __gx_entities(eid).y = y
    END SUB

    '    SUB GXEntityVX (eid AS INTEGER, vx AS INTEGER)
    SUB GXEntityVX (eid AS INTEGER, vx AS DOUBLE)
        __gx_entities(eid).vx = vx
    END SUB

    FUNCTION GXEntityVX (eid AS INTEGER)
        GXEntityVX = __gx_entities(eid).vx
    END FUNCTION

    'SUB GXEntityVY (eid AS INTEGER, vy AS INTEGER)
    SUB GXEntityVY (eid AS INTEGER, vy AS DOUBLE)
        __gx_entities(eid).vy = vy
    END SUB

    FUNCTION GXEntityVY (eid AS INTEGER)
        GXEntityVY = __gx_entities(eid).vy
    END FUNCTION


    FUNCTION GXEntityX (eid AS INTEGER)
        GXEntityX = __gx_entities(eid).x
    END FUNCTION

    FUNCTION GXEntityY (eid AS INTEGER)
        GXEntityY = __gx_entities(eid).y
    END FUNCTION

    FUNCTION GXEntityWidth (eid AS INTEGER)
        GXEntityWidth = __gx_entities(eid).width
    END FUNCTION

    FUNCTION GXEntityHeight (eid AS INTEGER)
        GXEntityHeight = __gx_entities(eid).height
    END FUNCTION

    SUB GXEntityFrameNext (eid AS INTEGER)
        IF __gx_entities(eid).animateMode = GXANIMATE_SINGLE THEN
            IF __gx_entities(eid).spriteFrame + 1 >= __gx_entities(eid).seqFrames THEN
                EXIT SUB
            END IF
        END IF

        __gx_entities(eid).spriteFrame = __gx_entities(eid).spriteFrame + 1
        IF __gx_entities(eid).spriteFrame > __gx_entities(eid).seqFrames THEN
            __gx_entities(eid).spriteFrame = 1
        END IF
    END SUB

    SUB GXEntityFrameSet (eid AS INTEGER, seq AS INTEGER, frame AS INTEGER)
        __gx_entities(eid).spriteSeq = seq
        __gx_entities(eid).spriteFrame = frame
    END SUB

    SUB GXEntityImageSet (eid AS INTEGER, filename AS STRING)
        __gx_entities(eid).image = __GX_ImageLoad(filename)
    END SUB

    SUB GXEntityType (eid AS INTEGER, etype AS INTEGER)
        __gx_entities(eid).type = etype
    END SUB

    FUNCTION GXEntityType (eid AS INTEGER)
        GXEntityType = __gx_entities(eid).type
    END FUNCTION


    ' TODO: Replace this implementation with a hash table lookup so we can scale
    '       efficiently when managing very large numbers of entities
    ' ----------------------------------------------------------------------------
    FUNCTION GXEntityUID$ (eid AS INTEGER)
        GXEntityUID = __GX_UID(GXTYPE_ENTITY, eid)
    END FUNCTION

    FUNCTION GXFontUID$ (fid AS INTEGER)
        GXFontUID = __GX_UID(GXTYPE_FONT, fid)
    END FUNCTION

    ' TODO: Expand this concept to lookup any GX object id by its user assigned id
    '       Maybe not "any" GX object... need to decide which ones would be applicable
    FUNCTION GX (uid AS STRING * 10)
        GX = 0
        DIM i AS INTEGER
        FOR i = 1 TO UBOUND(__gx_objects)
            IF RTRIM$(__gx_objects(i).uid) = uid THEN
                GX = __gx_objects(i).id
                EXIT FUNCTION
            END IF
        NEXT i
    END FUNCTION

    SUB __GX (uid AS STRING * 10, id AS INTEGER, otype AS INTEGER)
        DIM count AS INTEGER
        count = UBOUND(__gx_objects) + 1
        REDIM _PRESERVE __gx_objects(count) AS GXObject
        __gx_objects(count).uid = uid
        __gx_objects(count).id = id
        __gx_objects(count).type = otype
    END SUB

    FUNCTION __GX_UID$ (otype AS INTEGER, id AS INTEGER)
        DIM uid AS STRING
        DIM i AS INTEGER
        FOR i = 1 TO UBOUND(__gx_objects)
            IF __gx_objects(i).type = otype THEN
                IF __gx_objects(i).id = id THEN
                    uid = RTRIM$(__gx_objects(i).uid)
                END IF
            END IF
        NEXT i
        __GX_UID = uid
    END FUNCTION
    ' ----------------------------------------------------------------------------


    SUB GXEntityApplyGravity (eid AS INTEGER, gravity AS INTEGER)
        __gx_entities(eid).applyGravity = gravity
    END SUB

    FUNCTION GXEntityApplyGravity (eid AS INTEGER)
        GXEntityApplyGravity = __gx_entities(eid).applyGravity
    END FUNCTION

    SUB GXEntityCollisionOffset (eid AS INTEGER, left AS INTEGER, top AS INTEGER, right AS INTEGER, bottom AS INTEGER)
        __gx_entities(eid).coLeft = left
        __gx_entities(eid).coTop = top
        __gx_entities(eid).coRight = right
        __gx_entities(eid).coBottom = bottom
    END SUB

    FUNCTION GXEntityCollisionOffsetLeft (eid AS INTEGER)
        GXEntityCollisionOffsetLeft = __gx_entities(eid).coLeft
    END FUNCTION

    FUNCTION GXEntityCollisionOffsetTop (eid AS INTEGER)
        GXEntityCollisionOffsetTop = __gx_entities(eid).coTop
    END FUNCTION

    FUNCTION GXEntityCollisionOffsetRight (eid AS INTEGER)
        GXEntityCollisionOffsetRight = __gx_entities(eid).coRight
    END FUNCTION

    FUNCTION GXEntityCollisionOffsetBottom (eid AS INTEGER)
        GXEntityCollisionOffsetBottom = __gx_entities(eid).coBottom
    END FUNCTION


    FUNCTION GXPlayerCreate (eid AS INTEGER)
        __gx_player_count = __gx_player_count + 1
        REDIM _PRESERVE __gx_players(__gx_player_count) AS GXPlayer
        REDIM _PRESERVE __gx_player_keymap(10, __gx_player_count) AS GXAction
        __gx_players(__gx_player_count).eid = eid
        __gx_players(__gx_player_count).walkSpeed = 60
        __gx_players(__gx_player_count).runSpeed = 120
        __gx_players(__gx_player_count).jumpSpeed = 120
        GXPlayerCreate = __gx_player_count
    END FUNCTION

    SUB GXPlayerMoveSpeed (pid AS INTEGER, moveSpeed AS INTEGER)
        __gx_players(pid).walkSpeed = moveSpeed
    END SUB

    SUB GXPlayerJumpSpeed (pid AS INTEGER, jumpSpeed AS INTEGER)
        __gx_players(pid).jumpSpeed = jumpSpeed
    END SUB

    SUB GXPlayerActionKey (pid AS INTEGER, actionType AS INTEGER, k AS LONG)
        __gx_player_keymap(actionType, pid).type = actionType
        __gx_player_keymap(actionType, pid).diDeviceType = GXDEVICE_KEYBOARD
        __gx_player_keymap(actionType, pid).diDeviceId = 1
        __gx_player_keymap(actionType, pid).diInputType = GXDEVICE_BUTTON
        __gx_player_keymap(actionType, pid).diInputId = k
        __gx_player_keymap(actionType, pid).diInputValue = -1
    END SUB

    FUNCTION GXPlayerActionKey (pid AS INTEGER, actionType AS INTEGER)
        IF __gx_player_keymap(actionType, pid).diDeviceType = GXDEVICE_KEYBOARD THEN
            GXPlayerActionKey = __gx_player_keymap(actionType, pid).diInputId
        ELSE
            GXPlayerActionKey = 0
        END IF
    END FUNCTION

    SUB GXPlayerActionDisabled (pid AS INTEGER, actionType AS INTEGER, disabled AS INTEGER)
        __gx_player_keymap(actionType, pid).disabled = disabled
    END SUB

    FUNCTION GXPlayerActionDisabled (pid AS INTEGER, actionType AS INTEGER)
        GXPlayerActionDisabled = __gx_player_keymap(actionType, pid).disabled
    END FUNCTION

    SUB GXPlayerActionInput (pid AS INTEGER, actionType AS INTEGER, di AS GXDeviceInput)
        IF di.deviceId = 0 THEN
            ' Get the currently set device input values
            __GX_ActionInput __gx_player_keymap(actionType, pid), di
        ELSE
            ' Set the device input
            __gx_player_keymap(actionType, pid).type = actionType
            __gx_player_keymap(actionType, pid).diDeviceId = di.deviceId
            __gx_player_keymap(actionType, pid).diDeviceType = di.deviceType
            __gx_player_keymap(actionType, pid).diInputId = di.inputId
            __gx_player_keymap(actionType, pid).diInputType = di.inputType
            __gx_player_keymap(actionType, pid).diInputValue = di.inputValue
        END IF
    END SUB

    SUB GXPlayerMoveKey (pid AS INTEGER, action AS INTEGER, k AS LONG, animationSeq AS INTEGER, animationSpeed AS INTEGER)
        DIM di AS GXDeviceInput
        GXKeyInput k, di
        GXPlayerActionInput pid, action, di
        GXPlayerActionAnimationSeq pid, action, animationSeq
        GXPlayerActionAnimationSpeed pid, action, animationSpeed
    END SUB

    SUB GXPlayerMoveInput (pid AS INTEGER, action AS INTEGER, di AS GXDeviceInput, animationSeq AS INTEGER, animationSpeed AS INTEGER)
        GXPlayerActionInput pid, action, di
        GXPlayerActionAnimationSeq pid, action, animationSeq
        GXPlayerActionAnimationSpeed pid, action, animationSpeed
    END SUB

    SUB __GX_ActionInput (a AS GXAction, di AS GXDeviceInput)
        di.deviceId = a.diDeviceId
        di.deviceType = a.diDeviceType
        di.inputId = a.diInputId
        di.inputType = a.diInputType
        di.inputValue = a.diInputValue
    END SUB

    FUNCTION GXDeviceInputTest (di AS GXDeviceInput)
        DIM dcount AS INTEGER
        dcount = _DEVICES

        IF di.deviceId < 1 OR di.deviceId > dcount THEN
            GXDeviceInputTest = GX_FALSE
            EXIT SUB
        END IF

        DIM result AS INTEGER
        DIM dactive AS INTEGER
        dactive = _DEVICEINPUT(di.deviceId)

        IF di.inputType = GXDEVICE_BUTTON THEN
            IF _BUTTON(di.inputId) = di.inputValue THEN
                result = GX_TRUE
            END IF

        ELSEIF di.inputType = GXDEVICE_AXIS THEN
            IF _AXIS(di.inputId) = di.inputValue THEN
                result = GX_TRUE
            END IF
        END IF

        GXDeviceInputTest = result
    END FUNCTION


    SUB GXPlayerActionAnimationSeq (pid AS INTEGER, actionType AS INTEGER, animationSeq AS INTEGER)
        __gx_player_keymap(actionType, pid).animationSeq = animationSeq
    END SUB

    FUNCTION GXPlayerActionAnimationSeq (pid AS INTEGER, actionType AS INTEGER)
        GXPlayerActionAnimationSeq = __gx_player_keymap(actionType, pid).animationSeq
    END FUNCTION

    SUB GXPlayerActionAnimationMode (pid AS INTEGER, actionType AS INTEGER, animationMode AS INTEGER)
        __gx_player_keymap(actionType, pid).animationMode = animationMode
    END SUB

    FUNCTION GXPlayerActionAnimationMode (pid AS INTEGER, actionType AS INTEGER)
        GXPlayerActionAnimationMode = __gx_player_keymap(actionType, pid).animationMode
    END FUNCTION

    SUB GXPlayerActionAnimationSpeed (pid AS INTEGER, actionType AS INTEGER, animationSpeed AS INTEGER)
        __gx_player_keymap(actionType, pid).animationSpeed = animationSpeed
    END SUB

    FUNCTION GXPlayerActionAnimationSpeed (pid AS INTEGER, actionType AS INTEGER)
        GXPlayerActionAnimationSpeed = __gx_player_keymap(actionType, pid).animationSpeed
    END FUNCTION

    ' Sets the fullscreen status.
    ' When set to true the scene content will stretch to fill the entire screen.
    ' This value is set to false by default.
    SUB GXFullScreen (fullscreen AS INTEGER)
        IF fullscreen THEN
            _FULLSCREEN _SQUAREPIXELS
        ELSE
            _FULLSCREEN _OFF
        END IF
        __gx_scene.fullscreen = fullscreen
    END SUB

    ' Sets the fullscreen status.
    FUNCTION GXFullScreen
        GXFullScreen = __gx_scene.fullscreen
    END FUNCTION

    ' Adds a new background image to the current scene.  Multiple background images may be added to the scene.
    ' Background images are displayed in layers based on the order they are added.
    ' One of the following modes must be specified:
    '   GXBG_STRETCH - Stretch the background image to the size of the scene.
    '   GXBG_SCROLL  - Fit the height of the background image to the size of the screen.
    '                   Scroll the horizontal position relative to the position on the map.
    '   GXBG_WRAP    - Continuously wrap the background as the scene is moved horizontally.
    FUNCTION GXBackgroundAdd (imageFilename AS STRING, mode AS INTEGER)
        __gx_bg_count = __gx_bg_count + 1
        REDIM _PRESERVE __gx_bg(__gx_bg_count) AS GXBackground
        __gx_bg(__gx_bg_count).mode = mode
        IF mode = GXBG_WRAP THEN
            DIM img AS LONG
            img = __GX_ImageLoad(imageFilename)
            DIM w AS INTEGER, h AS INTEGER
            w = _WIDTH(img)
            h = _HEIGHT(img)
            DIM newImage AS LONG
            newImage = _NEWIMAGE(w * 2, h, 32)
            'newImage = __GX_HardwareImage(w * 2, h)
            _PUTIMAGE (0, 0)-(w, h), img, newImage
            _PUTIMAGE (w, 0)-(w * 2, h), img, newImage
            _FREEIMAGE img
            __gx_bg(__gx_bg_count).image = newImage
        ELSE
            __gx_bg(__gx_bg_count).image = __GX_ImageLoad(imageFilename)
        END IF
        GXBackgroundAdd = __gx_bg_count
    END FUNCTION

    SUB GXBackgroundY (gi AS INTEGER, y AS INTEGER)
        __gx_bg(gi).y = y
    END SUB

    SUB GXBackgroundHeight (gi AS INTEGER, height AS INTEGER)
        __gx_bg(gi).height = height
    END SUB

    ' Removes all background images from the scene.
    SUB GXBackgroundClear
        __gx_bg_count = 0
        REDIM __gx_bg(0) AS GXBackground
    END SUB

    SUB __GX_BackgroundDraw (bi AS INTEGER)
        DIM factor, xfactor
        DIM w AS LONG, h AS LONG, x AS LONG, y AS LONG

        IF __gx_bg(bi).mode = GXBG_STRETCH THEN
            _PUTIMAGE , __gx_bg(bi).image, __gx_scene.image

        ELSEIF __gx_bg(bi).mode = GXBG_SCROLL THEN
            factor = GXSceneWidth / GXSceneHeight
            h = _HEIGHT(__gx_bg(bi).image)
            w = h * factor
            'x = gx_bg(bi).xpos
            xfactor = GXSceneX / (GXMapColumns * GXTilesetWidth)
            x = xfactor * (_WIDTH(__gx_bg(bi).image) - w)
            _PUTIMAGE , __gx_bg(bi).image, __gx_scene.image, (x, 0)-(x + w, h)

        ELSEIF __gx_bg(bi).mode = GXBG_WRAP THEN
            h = __gx_bg(bi).height
            w = GXSceneWidth
            y = __gx_bg(bi).y
            x = (GXSceneX MOD _WIDTH(__gx_bg(bi).image)) / 2
            _PUTIMAGE (0, y)-(GXSceneWidth, y + h), __gx_bg(bi).image, __gx_scene.image, (x, 0)-(x + w, _HEIGHT(__gx_bg(bi).image))
            __gx_bg(bi).x = x + 1
            IF __gx_bg(bi).x > _WIDTH(__gx_bg(bi).image) / 2 THEN
                __gx_bg(bi).x = 0
            END IF
        END IF
    END SUB

    ' Gets the embedded flag for the scene.
    SUB GXSceneEmbedded (embedded AS INTEGER)
        __gx_scene.embedded = embedded
    END SUB

    ' Sets the embedded flag for the scene.
    ' The embedded flag should be set to true when the game loop is being
    ' managed manually or by an external framework (e.g. QB64 Inform).
    ' This value is set to false by default.
    FUNCTION GXSceneEmbedded
        GXSceneEmbedded = __gx_scene.embedded
    END FUNCTION

    FUNCTION __GX_HardwareImage& (iwidth AS INTEGER, iheight AS INTEGER)
        DIM newImage AS LONG, hwImage AS LONG
        newImage = _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
        hwImage = _COPYIMAGE(newImage, 33)
        PRINT hwImage
        _FREEIMAGE newImage
        __GX_HardwareImage = hwImage
    END FUNCTION

    ' Creates a new scene with the specified pixel width and height.
    SUB GXSceneCreate (swidth AS INTEGER, sheight AS INTEGER)
        __gx_scene.width = swidth
        __gx_scene.height = sheight

        IF GXSceneEmbedded = 0 THEN
            DIM oldimg AS LONG
            oldimg = _SCREENIMAGE
            SCREEN _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
            'DIM hwImage AS LONG
            'hwImage = __GX_HardwareImage(gx_scene.width, gx_scene.height)
            'SCREEN hwImage
            _FREEIMAGE oldimg
        END IF

        IF __gx_scene.image THEN _FREEIMAGE __gx_scene.image
        __gx_scene.image = _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
        'gx_scene.image = __GX_HardwareImage(gx_scene.width, gx_scene.height)

        IF NOT __gx_img_blank THEN __gx_img_blank = _NEWIMAGE(1, 1, 32)
        'IF NOT gx_img_blank THEN gx_img_blank = __GX_HardwareImage(1, 1)

        __gx_scene.scaleX = 1
        __gx_scene.scaleY = 1
    END SUB

    ' Scale the scene to the specified window size.
    SUB GXSceneWindowSize (swidth AS INTEGER, sheight AS INTEGER)
        DIM oldimg AS LONG
        oldimg = _SCREENIMAGE
        SCREEN _NEWIMAGE(swidth, sheight, 32)
        'SCREEN __GX_HardwareImage(swidth, sheight)
        _FREEIMAGE oldimg
        __gx_scene.scaleX = swidth / GXSceneWidth
        __gx_scene.scaleY = sheight / GXSceneHeight
    END SUB

    ' Scale the scene by the specified scale factor.
    SUB GXSceneScale (scale AS SINGLE)
        __gx_scene.scaleX = scale
        __gx_scene.scaleY = scale
        IF NOT GXSceneEmbedded THEN
            DIM oldimg AS LONG
            oldimg = _SCREENIMAGE
            SCREEN _NEWIMAGE(GXSceneWidth * __gx_scene.scaleX, GXSceneHeight * __gx_scene.scaleY, 32)
            'SCREEN __GX_HardwareImage(gx_scene.width * gx_scene.scaleX, gx_scene.height * gx_scene.scaleY)
            _FREEIMAGE oldimg
        END IF
    END SUB

    ' Resize the scene with the specified pixel width and height.
    SUB GXSceneResize (swidth AS INTEGER, sheight AS INTEGER)
        __gx_scene.width = swidth
        __gx_scene.height = sheight

        IF __gx_scene.image THEN _FREEIMAGE (__gx_scene.image)
        __gx_scene.image = _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
        'gx_scene.image = __GX_HardwareImage(gx_scene.width, gx_scene.height)

        IF NOT GXSceneEmbedded THEN
            DIM oldimg AS LONG
            oldimg = _SCREENIMAGE
            SCREEN _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
            'SCREEN __GX_HardwareImage(gx_scene.width, gx_scene.height)
            _FREEIMAGE oldimg
        END IF
        __GX_UpdateSceneSize
    END SUB

    SUB GXSceneDestroy
        _DELAY .1
        GXSceneStop
        _FREEIMAGE __gx_scene.image
        _FREEIMAGE __gx_img_blank
        __gx_scene.image = 0
        __gx_img_blank = 0
        DIM i AS INTEGER
        FOR i = 0 TO __gx_image_count - 1
            _FREEIMAGE __gx_images(i).id
        NEXT i
        __gx_image_count = 0
        REDIM __gx_images(0) AS GXImage
    END SUB

    SUB __GX_CustomEvent (eventType AS INTEGER)
        DIM e AS GXEvent
        e.event = eventType
        GXOnGameEvent e
    END SUB

    SUB __GX_CustomDrawEvent (eventType AS INTEGER)
        _DEST __gx_scene.image
        __GX_CustomEvent eventType
        _DEST 0
    END SUB

    ' Returns the current frame rate (expressed in frames-per-second or FPS).
    SUB GXFrameRate (frameRate AS INTEGER)
        __gx_framerate = frameRate
    END SUB

    ' Sets current frame rate (expressed in frames-per-second or FPS).
    ' The default value for the frame rate is 60
    FUNCTION GXFrameRate
        GXFrameRate = __gx_framerate
    END FUNCTION

    ' Returns the current frame.
    ' This is a frame counter that starts when GXSceneStart is called.
    ' It is initially set to zero and is incremented on each frame.
    FUNCTION GXFrame
        GXFrame = __gx_scene.frame
    END FUNCTION

    ' Draw the scene.
    ' This method is called automatically when GX is managing the event/game loop.
    ' Call this method for each page draw event when the event/game loop is being
    ' handled externally.
    SUB GXSceneDraw
        IF __gx_map_loading THEN EXIT SUB
        DIM ei AS INTEGER
        DIM ei2 AS INTEGER
        DIM frame AS INTEGER
        frame = __gx_scene.frame MOD GXFrameRate + 1

        ' If the screen has been resized, resize the destination screen image
        IF _RESIZE AND NOT GXSceneEmbedded THEN
            '_FREEIMAGE _SOURCE
            'SCREEN _NEWIMAGE(_RESIZEWIDTH, _RESIZEHEIGHT, 32)
            GXSceneWindowSize _RESIZEWIDTH, _RESIZEHEIGHT
        END IF

        ' Clear the background
        _DONTBLEND __gx_scene.image
        _PUTIMAGE , __gx_img_blank, __gx_scene.image
        _BLEND __gx_scene.image

        ' Draw background images, if present
        DIM bi AS INTEGER
        FOR bi = 1 TO __gx_bg_count
            __GX_BackgroundDraw bi
        NEXT bi

        'Call out to any custom screen drawing
        __GX_CustomDrawEvent GXEVENT_DRAWBG

        ' Draw the map tiles
        GXMapDraw
        IF GXDebug THEN __GX_DebugMapTile

        'Call out to any custom screen drawing
        __GX_CustomDrawEvent GXEVENT_DRAWMAP

        ' Draw the entities
        DIM e AS GXEntity
        FOR ei = 1 TO __gx_entity_count
            e = __gx_entities(ei)
            IF e.screen = 0 THEN
                IF __GX_RectCollide(e.x, e.y, e.width, e.height, GXSceneX, GXSceneY, GXSceneWidth, GXSceneHeight) THEN
                    __GX_EntityDraw e
                END IF
            END IF
            IF e.animate > 0 THEN
                IF frame MOD (GXFrameRate / e.animate) = 0 THEN
                    GXEntityFrameNext ei
                END IF
            END IF
        NEXT ei

        ' Draw the screen entities which should appear on top of the other game entities
        ' and have a fixed position
        FOR ei2 = 1 TO __gx_entity_count
            IF __gx_entities(ei2).screen = 1 THEN
                __GX_EntityDraw __gx_entities(ei2)
            END IF
        NEXT ei2

        'Call out to any custom screen drawing
        __GX_CustomDrawEvent GXEVENT_DRAWSCREEN
        IF GXDebug THEN __GX_DebugFrameRate

        ' Copy the background image to the screen
        __GX_CustomEvent GXEVENT_PAINTBEFORE
        _DONTBLEND
        _PUTIMAGE , __gx_scene.image
        _BLEND
        __GX_CustomEvent GXEVENT_PAINTAFTER
    END SUB

    ' Moves the scene position by the number of pixels specified by the dx and dy values.
    ' The default position for a scene is (0,0). Negative x and y values are valid.
    ' A non-zero value for dx will move the scene by the number of pixels specified to the right or left.
    ' A non-zero value for dy will move the scene by the number of pixels specified up or down.
    SUB GXSceneMove (dx AS LONG, dy AS LONG)
        __gx_scene.x = GXSceneX + dx
        __gx_scene.y = GXSceneY + dy
    END SUB

    ' Positions the scene at the specified x and y coordinates.
    ' The default position for a scene is (0,0). Negative x and y values are valid.
    SUB GXScenePos (x AS LONG, y AS LONG)
        __gx_scene.x = x
        __gx_scene.y = y
    END SUB

    ' Returns the scene's current y position.
    FUNCTION GXSceneX
        GXSceneX = __gx_scene.x
    END FUNCTION

    ' Returns the scene's current y position.
    FUNCTION GXSceneY
        GXSceneY = __gx_scene.y
    END FUNCTION

    ' Returns the scene width.
    FUNCTION GXSceneWidth
        GXSceneWidth = __gx_scene.width
    END FUNCTION

    ' Returns the scene height.
    FUNCTION GXSceneHeight
        GXSceneHeight = __gx_scene.height
    END FUNCTION

    ' Returns the number of tile columns that can be displayed within the scene.
    ' This value will be zero unless a tiled map has been created or loaded.
    FUNCTION GXSceneColumns
        GXSceneColumns = __gx_scene.columns
    END FUNCTION

    ' Returns the number of tile rows that can be displayed within the scene.
    ' This value will be zero unless a tiled map has been created or loaded.
    FUNCTION GXSceneRows
        GXSceneRows = __gx_scene.rows
    END FUNCTION

    ' Start the game loop.
    ' This method will not return control to the calling program until the
    ' game loop is interrupted with the GXSceneStop method.
    ' Game events will be sent to the GXOnGameEvent method during the game
    ' loop execution.
    SUB GXSceneStart
        __gx_scene.frame = 0
        __gx_scene.active = 1

        'DIM dcount AS INTEGER
        'dcount = _DEVICES
        DO
            _LIMIT GXFrameRate

            ' Update the scene
            GXSceneUpdate

            ' Redraw the scene
            GXSceneDraw
            _DISPLAY

        LOOP WHILE __gx_scene.active
    END SUB

    SUB GXSceneUpdate
        __gx_scene.frame = __gx_scene.frame + 1

        ' Capture mouse events when not embedded
        IF NOT GXSceneEmbedded THEN
            DIM mi AS LONG
            mi = _MOUSEINPUT
        END IF

        ' Call custom game update logic
        __GX_CustomEvent GXEVENT_UPDATE

        ' Perform any movement for registered player entities
        DIM i AS INTEGER
        FOR i = 1 TO __gx_player_count
            __GX_PlayerAction i
        NEXT i

        ' Check for entity movement and collisions
        ' TODO: filter out non-moving entities
        __GX_SceneMoveEntities

        ' Perform any auto-scene moves
        DIM sx AS LONG, sy AS LONG
        IF __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER OR _
           __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X OR _
           __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X_POS OR _
           __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X_NEG THEN
            sx = (GXEntityX(__gx_scene.followEntity) + GXEntityWidth(__gx_scene.followEntity) / 2) - GXSceneWidth / 2
            IF (sx < GXSceneX AND __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X_POS) OR _
               (sx > GXSceneX AND __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X_NEG) THEN
                ' don't move the scene
            ELSE
                GXScenePos sx, GXSceneY
            END IF
        END IF
        IF __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER OR _
           __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_Y THEN
            sy = (GXEntityY(__gx_scene.followEntity) + GXEntityHeight(__gx_scene.followEntity) / 2) - GXSceneHeight / 2
            GXScenePos GXSceneX, sy
        END IF

        ' Check the scene move constraints
        IF __gx_scene.constrainMode = GXSCENE_CONSTRAIN_TO_MAP THEN
            DIM mwidth AS INTEGER
            DIM mheight AS INTEGER
            mwidth = GXMapColumns * GXTilesetWidth
            mheight = GXMapRows * GXTilesetHeight
            sx = GXSceneX
            IF sx < 0 THEN
                sx = 0
            ELSEIF sx + GXSceneWidth > mwidth THEN
                sx = mwidth - GXSceneWidth
                IF sx < 0 THEN sx = 0
            END IF

            sy = GXSceneY
            IF sy < 0 THEN
                sy = 0
            ELSEIF sy + GXSceneHeight > mheight THEN
                sy = mheight - GXSceneHeight
                IF sy < 0 THEN sy = 0
            END IF
            GXScenePos sx, sy
        END IF

        IF NOT GXSceneEmbedded THEN
            WHILE _MOUSEINPUT
                ' Flush mouse event buffer
            WEND
        END IF
    END SUB

    ' TODO: revisit "follow" wording.
    SUB GXSceneFollowEntity (eid AS INTEGER, mode AS INTEGER)
        __gx_scene.followEntity = eid
        __gx_scene.followMode = mode
    END SUB

    SUB GXSceneConstrain (mode AS INTEGER)
        __gx_scene.constrainMode = mode
    END SUB

    SUB __GX_SceneMoveEntities
        DIM frameFactor AS DOUBLE
        frameFactor = 1 / GXFrameRate

        'DIM e AS GXEntity
        DIM eid AS INTEGER, ci AS INTEGER
        REDIM centities(0) AS INTEGER
        DIM ecount AS INTEGER
        FOR eid = 1 TO __gx_entity_count

            IF __gx_entities(eid).screen = 0 THEN
                ' Check for entity collisions
                ecount = __GX_EntityCollision(eid, 0, 0, centities())
                FOR ci = 1 TO ecount
                    DIM ee AS GXEvent
                    ee.event = GXEVENT_COLLISION_ENTITY
                    ee.entity = eid
                    ee.collisionEntity = centities(ci)
                    GXOnGameEvent ee
                NEXT ci

                ' Move the entity
                IF __gx_entities(eid).applyGravity = 1 THEN
                    DIM tpos AS GXPosition
                    DIM centity AS INTEGER
                    DIM tmove AS INTEGER
                    tmove = __GX_EntityTestMove(eid, 0, 1, tpos, centity)
                    centity = 0
                    IF (__gx_entities(eid).jumping = 1 AND __gx_entities(eid).vy < 0) OR tmove THEN
                        IF __gx_entities(eid).jumpstart = 0 THEN
                            __gx_entities(eid).jumpstart = GXFrame - 45
                        ELSE
                            ' calculate the number of seconds since the gravity started being applied
                            DIM t
                            t = (GXFrame - __gx_entities(eid).jumpstart) / GXFrameRate
                            __gx_entities(eid).vy = __gx_entities(eid).vy + 9.8 * t ^ 2 / 2
                        END IF
                        'ELSE
                    END IF

                    ' test to see if we have hit the block or entity above or below
                    tmove = __GX_EntityTestMove(eid, 0, __gx_entities(eid).vy * frameFactor, tpos, centity)
                    IF tmove = 0 THEN
                        IF __gx_entities(eid).vy < 0 THEN

                            ' if we hit a block above, then reverse the current velocity
                            ' and make sure the entity does not move above the collision offset
                            __gx_entities(eid).vy = -__gx_entities(eid).vy
                            '                    gx_entities(eid).jumpspeed = 0
                            IF (centity) THEN
                                __gx_entities(eid).y = GXEntityY(centity) + GXEntityHeight(centity) - GXEntityCollisionOffsetTop(eid)
                            ELSE
                                __gx_entities(eid).y = GXTilesetHeight * (tpos.y + 1) - GXEntityCollisionOffsetTop(eid)
                            END IF

                        ELSEIF __gx_entities(eid).vy > 0 THEN

                            ' if we hit a block below, then zero out the jump speed and end the "fall"
                            ' and make sure the entity does not move below the collision offset
                            __gx_entities(eid).jumpstart = 0
                            __gx_entities(eid).jumping = 0
                            __gx_entities(eid).vy = 0

                            IF (centity) THEN
                                __gx_entities(eid).y = GXEntityY(centity) - GXEntityHeight(eid)
                            ELSE
                                __gx_entities(eid).y = GXTilesetHeight * (tpos.y) - (GXEntityHeight(eid) - GXEntityCollisionOffsetBottom(eid))
                            END IF
                        END IF

                        'END IF
                    END IF

                END IF ' end if apply gravity

                ' apply the move vector to the entity's position
                IF __gx_entities(eid).vx THEN
                    __gx_entities(eid).x = __gx_entities(eid).x + __gx_entities(eid).vx * frameFactor
                END IF
                IF __gx_entities(eid).vy THEN
                    __gx_entities(eid).y = __gx_entities(eid).y + __gx_entities(eid).vy * frameFactor
                END IF
            END IF
        NEXT eid
    END SUB

    ' Stop the game loop.
    ' This method will cause the game loop to end and return control to the calling program.
    SUB GXSceneStop
        __gx_scene.active = 0
    END SUB



    SUB GXMapCreate (columns AS INTEGER, rows AS INTEGER, layers AS INTEGER)
        __gx_map.columns = columns
        __gx_map.rows = rows
        __gx_map.layers = layers
        __gx_map.version = 2

        DIM layerSize AS LONG
        layerSize = rows * columns
        REDIM __gx_map_layers(layerSize, layers) AS GXMapTile
        REDIM __gx_map_layer_info(layers) AS GXMapLayer
        DIM l AS INTEGER
        FOR l = 1 TO layers
            __gx_map_layer_info(l).id = l
        NEXT l
    END SUB

    FUNCTION GXMapColumns
        GXMapColumns = __gx_map.columns
    END FUNCTION

    FUNCTION GXMapRows
        GXMapRows = __gx_map.rows
    END FUNCTION

    FUNCTION GXMapLayers
        GXMapLayers = __gx_map.layers
    END FUNCTION

    SUB GXMapLayerVisible (layer AS INTEGER, visible AS INTEGER)
        __gx_map_layer_info(layer).hidden = NOT visible
    END SUB

    FUNCTION GXMapLayerVisible (layer AS INTEGER)
        GXMapLayerVisible = NOT __gx_map_layer_info(layer).hidden
    END FUNCTION

    SUB GXMapLayerAdd
        REDIM _PRESERVE __gx_map_layer_info(GXMapLayers + 1) AS GXMapLayer
        REDIM _PRESERVE __gx_map_layers(GXMapRows * GXMapColumns, GXMapLayers + 1) AS GXMapTile
        __gx_map_layer_info(GXMapLayers + 1).id = GXMapLayers + 1
        __gx_map.layers = GXMapLayers + 1
    END SUB

    SUB GXMapLayerInsert (beforeLayer AS INTEGER)
        IF beforeLayer < 1 OR beforeLayer > GXMapLayers THEN EXIT SUB

        GXMapLayerAdd
        DIM layer AS INTEGER
        DIM tile AS INTEGER
        FOR layer = GXMapLayers TO beforeLayer + 1 STEP -1
            'gx_map_layer_info(layer) = gx_map_layer_info(layer - 1)
            FOR tile = 0 TO GXMapRows * GXMapColumns
                __gx_map_layers(tile, layer) = __gx_map_layers(tile, layer - 1)
            NEXT tile
        NEXT layer
        DIM blankTile AS GXMapTile
        FOR tile = 0 TO GXMapRows * GXMapColumns
            __gx_map_layers(tile, beforeLayer) = blankTile
        NEXT tile
    END SUB

    SUB GXMapLayerRemove (removeLayer AS INTEGER)
        IF removeLayer < 1 OR removeLayer > GXMapLayers OR GXMapLayers < 2 THEN EXIT SUB

        DIM layer AS INTEGER
        DIM tile AS INTEGER
        FOR layer = removeLayer TO GXMapLayers - 1
            FOR tile = 0 TO GXMapRows * GXMapColumns
                __gx_map_layers(tile, layer) = __gx_map_layers(tile, layer + 1)
            NEXT tile
        NEXT layer

        REDIM _PRESERVE __gx_map_layer_info(GXMapLayers - 1) AS GXMapLayer
        REDIM _PRESERVE __gx_map_layers(GXMapRows * GXMapColumns, GXMapLayers - 1) AS GXMapTile
        __gx_map.layers = GXMapLayers - 1
    END SUB

    SUB GXMapResize (columns AS INTEGER, rows AS INTEGER)
        DIM tempMap(GXMapRows * GXMapColumns, GXMapLayers) AS GXMapTile
        DIM m1 AS _MEM: m1 = _MEM(__gx_map_layers())
        DIM m2 AS _MEM: m2 = _MEM(tempMap())
        _MEMCOPY m1, m1.OFFSET, m1.SIZE TO m2, m2.OFFSET
        _MEMFREE m1
        _MEMFREE m2

        REDIM __gx_map_layers(rows * columns, GXMapLayers) AS GXMapTile

        DIM layer AS INTEGER
        DIM row AS INTEGER
        DIM column AS INTEGER
        DIM maxColumns AS INTEGER
        DIM maxRows AS INTEGER
        IF columns > GXMapColumns THEN
            maxColumns = GXMapColumns
        ELSE
            maxColumns = columns
        END IF
        IF rows > GXMapRows THEN
            maxRows = GXMapRows
        ELSE
            maxRows = rows
        END IF

        DIM blankTile AS GXMapTile
        FOR layer = 1 TO GXMapLayers
            FOR row = 0 TO maxRows - 1
                FOR column = 0 TO maxColumns - 1
                    IF column >= GXMapColumns OR row >= GXMapRows THEN
                        __gx_map_layers(row * columns + column, layer) = blankTile
                    ELSE
                        __gx_map_layers(row * columns + column, layer) = tempMap(row * GXMapColumns + column, layer)
                    END IF
                NEXT column
            NEXT row
        NEXT layer

        __gx_map.columns = columns
        __gx_map.rows = rows
    END SUB

    SUB GXMapDraw
        IF GXMapRows < 1 THEN EXIT SUB

        DIM tpos AS GXPosition
        DIM srow, scol, row, col
        DIM layer AS INTEGER, li AS INTEGER
        DIM xoffset, yoffset, pcol, prow AS LONG
        DIM t AS LONG, tx AS LONG, ty AS LONG
        DIM rowOffset AS LONG
        'DIM rowOffset AS DOUBLE, singleRowOffset AS DOUBLE
        DIM colOffset AS LONG

        xoffset = GXSceneX MOD GXTilesetWidth
        pcol = FIX(GXSceneX / GXTilesetWidth)
        IF GXMapIsometric THEN
            prow = FIX(GXSceneY / (GXTilesetWidth / 4))
            yoffset = GXSceneY MOD (GXTilesetWidth / 4)
        ELSE
            prow = FIX(GXSceneY / GXTilesetHeight)
            yoffset = GXSceneY MOD GXTilesetHeight
        END IF

        srow = 0
        rowOffset = 0
        'singleRowOffset = 0
        'IF GXMapIsometric THEN
        '    singleRowOffset = GXTilesetHeight - GXTilesetWidth / 4
        '    rowOffset = singleRowOffset
        'END IF

        FOR row = prow TO prow + GXSceneRows + 1 'TODO: currently rendering too many rows for isometric maps
            scol = 0
            IF NOT GXMapIsometric THEN
                colOffset = 0
            ELSE
                colOffset = 0 'GXTilesetWidth / 2
                IF row MOD 2 = 0 THEN colOffset = GXTilesetWidth / 2
            END IF

            IF GXMapIsometric THEN
                'rowOffset = (row - prow + 1) * _ROUND(GXTilesetHeight - GXTilesetWidth / 4)
                rowOffset = (row - prow + 1) * (GXTilesetHeight - GXTilesetWidth / 4)
            END IF

            FOR col = pcol TO pcol + GXSceneColumns + 1
                'FOR layer = 1 TO gx_map.layers
                FOR li = 1 TO GXMapLayers
                    IF NOT __gx_map_layer_info(li).hidden THEN
                        layer = __gx_map_layer_info(li).id

                        t = GXMapTile(col, row, layer)
                        IF t > 0 THEN
                            DIM t1 AS INTEGER: t1 = t
                            t = __GX_TileFrame(t)
                            GXTilesetPos t, tpos
                            tx = scol * GXTilesetWidth - xoffset - colOffset
                            ty = srow * GXTilesetHeight - yoffset - rowOffset
                            GXSpriteDraw GXTilesetImage, tx, ty, tpos.y, tpos.x, GXTilesetWidth, GXTilesetHeight, __gx_scene.image
                        END IF
                    END IF
                NEXT li
                scol = scol + 1
            NEXT col
            srow = srow + 1
            'IF GXMapIsometric THEN rowOffset = rowOffset + singleRowOffset '(GXTilesetHeight * .75)
        NEXT row

        ' Perform tile animation
        FOR t = 1 TO GXTilesetColumns * GXTilesetRows
            __GX_TileFrameNext t
        NEXT t
    END SUB

    SUB GXMapTilePosAt (x AS INTEGER, y AS INTEGER, tpos AS GXPosition)
        IF NOT GXMapIsometric THEN
            tpos.x = FIX((x + GXSceneX) / GXTilesetWidth)
            tpos.y = FIX((y + GXSceneY) / GXTilesetHeight)
        ELSE
            DIM tileWidthHalf AS INTEGER: tileWidthHalf = GXTilesetWidth / 2
            DIM tileHeightHalf AS INTEGER: tileHeightHalf = GXTilesetHeight / 2
            DIM sx AS LONG: sx = x / tileWidthHalf

            DIM offset AS INTEGER
            IF sx MOD 2 = 1 THEN
                offset = tileWidthHalf
            ELSE
                offset = 0
            END IF

            tpos.y = (2 * y) / tileHeightHalf
            tpos.x = (x - offset) / GXTilesetWidth
        END IF
    END SUB

    FUNCTION __GX_TileFrame (tileId)
        IF tileId < 0 OR tileId > UBOUND(__gx_tileset_tiles) THEN
            __GX_TileFrame = tileId
            EXIT SUB
        END IF

        IF __gx_tileset_tiles(tileId).animationId = 0 THEN
            __GX_TileFrame = tileId
            EXIT SUB
        END IF

        DIM currFrame AS INTEGER
        currFrame = __gx_tileset_tiles(tileId).animationId
        IF __gx_tileset_tiles(tileId).animationFrame > 0 THEN
            currFrame = __gx_tileset_tiles(tileId).animationFrame
        END IF

        __GX_TileFrame = __gx_tileset_animations(currFrame).tileId
    END FUNCTION


    SUB __GX_TileFrameNext (tileId AS LONG)
        IF tileId < 0 OR tileId > UBOUND(__gx_tileset_tiles) THEN EXIT SUB
        IF __gx_tileset_tiles(tileId).animationId = 0 THEN EXIT SUB

        DIM frame AS INTEGER
        frame = GXFrame MOD GXFrameRate + 1

        DIM firstFrame AS INTEGER
        firstFrame = __gx_tileset_tiles(tileId).animationId

        DIM animationSpeed AS INTEGER
        animationSpeed = __gx_tileset_tiles(tileId).animationSpeed

        IF frame MOD (GXFrameRate / animationSpeed) = 0 THEN
            DIM currFrame AS INTEGER
            currFrame = firstFrame
            IF __gx_tileset_tiles(tileId).animationFrame > 0 THEN
                currFrame = __gx_tileset_tiles(tileId).animationFrame
            END IF

            DIM nextFrame AS INTEGER
            nextFrame = __gx_tileset_animations(currFrame).nextFrame
            IF nextFrame = 0 THEN
                nextFrame = firstFrame
            END IF

            __gx_tileset_tiles(tileId).animationFrame = nextFrame
        END IF
    END SUB


    SUB GXMapTile (col AS INTEGER, row AS INTEGER, layer AS INTEGER, tile AS INTEGER)
        IF tile < 0 THEN EXIT SUB
        'TODO: check for tile greater than max and exit early

        IF (col >= 0 AND col <= GXMapColumns AND row >= 0 AND row < GXMapRows) THEN
            DIM mpos AS LONG
            mpos = row * GXMapColumns + col
            __gx_map_layers(mpos, layer).tile = tile
        END IF
    END SUB

    FUNCTION GXMapTile (col AS INTEGER, row AS INTEGER, layer AS INTEGER)
        IF col < 0 OR col >= GXMapColumns OR row < 0 OR row >= GXMapRows OR layer > GXMapLayers THEN
            GXMapTile = 0
        ELSE
            DIM mpos AS LONG
            mpos = row * GXMapColumns + col
            'IF mpos > UBOUND(gx_map_layers) THEN
            '    GXMapTile = 0
            '    EXIT SUB
            'END IF
            GXMapTile = __gx_map_layers(mpos, layer).tile
        END IF
    END FUNCTION

    FUNCTION GXMapTileDepth (col AS INTEGER, row AS INTEGER)
        IF col < 0 OR col >= GXMapColumns OR row < 0 OR row >= GXMapRows THEN
            GXMapTileDepth = 0
        ELSE
            DIM layer AS INTEGER
            FOR layer = GXMapLayers TO 1 STEP -1
                IF GXMapTile(col, row, layer) > 0 THEN
                    GXMapTileDepth = layer
                    EXIT SUB
                END IF
            NEXT layer
            GXMapTileDepth = 0
        END IF
    END FUNCTION

    SUB GXMapTileAdd (col AS INTEGER, row AS INTEGER, tile AS INTEGER)
        IF tile < 1 THEN EXIT SUB
        'TODO: check for tile greater than max and exit early

        IF (col >= 0 AND col <= GXMapColumns AND row >= 0 AND row <= GXMapRows) THEN
            DIM layer AS INTEGER
            FOR layer = 1 TO GXMapLayers
                IF GXMapTile(col, row, layer) = 0 THEN
                    GXMapTile col, row, layer, tile
                    EXIT SUB
                END IF
            NEXT layer
        END IF
    END SUB

    SUB GXMapTileRemove (col AS INTEGER, row AS INTEGER)
        IF (col >= 0 AND col <= GXMapColumns AND row >= 0 AND row < GXMapRows) THEN
            DIM layer AS INTEGER
            FOR layer = GXMapLayers TO 1 STEP -1
                IF GXMapTile(col, row, layer) THEN
                    GXMapTile col, row, layer, 0
                    EXIT SUB
                END IF
            NEXT layer
        END IF
    END SUB

    FUNCTION GXMapVersion
        GXMapVersion = __gx_map.version
    END FUNCTION

    SUB GXMapSave (filename AS STRING)
        DIM version AS INTEGER
        DIM col AS INTEGER
        DIM row AS INTEGER
        DIM layer AS INTEGER
        DIM tile AS INTEGER
        DIM depth AS INTEGER

        version = 2

        ' TODO: check to see if the tileset image has been removed before deleting
        '       the original file
        IF _FILEEXISTS(filename) THEN
            KILL filename
        END IF
        OPEN filename FOR BINARY AS #1

        ' Save the map version
        PUT #1, , version

        ' Save the map meta-data
        PUT #1, , __gx_map.columns
        PUT #1, , __gx_map.rows
        PUT #1, , __gx_map.layers
        PUT #1, , __gx_map.isometric

        ' Save the map tile layer data
        ' TODO: use a temp file strategy that will avoid file collisions
        '       or potentially read and write from memory instead
        OPEN "./tmp/layer" FOR BINARY AS #2
        PUT #2, , __gx_map_layers()
        CLOSE #2
        OPEN "./tmp/layer" FOR BINARY AS #2
        DIM lstr AS STRING
        lstr = STRING$(LOF(2), " ")
        GET #2, , lstr
        CLOSE #2
        KILL "./tmp/layer"
        lstr = _DEFLATE$(lstr)
        __GX_WriteString lstr

        ' Save the tilemap information
        __GX_TilesetSave

        CLOSE #1
    END SUB

    ' Load the map
    SUB GXMapLoad (filename AS STRING)
        __gx_map_loading = 1

        OPEN filename FOR BINARY AS #1

        ' Read the version
        GET #1, 1, __gx_map.version

        ' For backwards compatibility, add new versions of the
        ' load function to continue to support older maps
        SELECT CASE GXMapVersion
            CASE 1: __GX_MapLoadV1 filename
            CASE 2: __GX_MapLoadV2 filename
        END SELECT

        CLOSE #1

        __gx_map_loading = 0
    END SUB

    ' Load a version 2 map
    SUB __GX_MapLoadV2 (filename AS STRING)
        DIM columns AS INTEGER
        DIM rows AS INTEGER
        DIM layers AS INTEGER
        DIM col AS INTEGER
        DIM row AS INTEGER
        DIM layer AS INTEGER
        DIM depth AS INTEGER
        DIM tile AS INTEGER

        GET #1, , columns
        GET #1, , rows
        GET #1, , layers
        GET #1, , __gx_map.isometric
        GXMapCreate columns, rows, layers
        '--------------------------------------------------------------
        ' temporary code - remove
        '--------------------------------------------------------------
        'DIM temp(layers, columns * rows) AS GXMapTile
        '--------------------------------------------------------------
        ' END temporary code - remove
        '--------------------------------------------------------------


        ' Read the map tile layer data
        DIM lstr AS STRING
        lstr = __GX_ReadString
        lstr = _INFLATE$(lstr)
        ' TODO: use a temp file strategy that will avoid file collisions
        '       or potentially read and write from memory instead
        OPEN "./tmp/layer" FOR BINARY AS #2
        PUT #2, , lstr
        CLOSE #2
        OPEN "./tmp/layer" FOR BINARY AS #2
        GET #2, , __gx_map_layers()
        CLOSE #2
        KILL "./tmp/layer"

        '--------------------------------------------------------------
        ' temporary code - remove
        '--------------------------------------------------------------
        'DIM l AS INTEGER, t AS INTEGER
        'FOR l = 1 TO layers
        '    FOR t = 0 TO columns * rows
        '        gx_map_layers(t, l) = temp(l, t)
        '    NEXT t
        'NEXT l
        '--------------------------------------------------------------
        ' END temporary code - remove
        '--------------------------------------------------------------


        ' Read the tileset information
        __GX_TilesetLoad
        'DIM tilesetFilename AS STRING
        'DIM tilewidth AS INTEGER
        'DIM tileheight AS INTEGER
        'tilesetFilename = __GX_ReadString ' original tileset filename
        'GET #1, , tilewidth
        'GET #1, , tileheight

        '' If the map has an embedded tileset image, save it to a temp file location
        'DIM tsize AS LONG
        'GET #1, , tsize
        'IF NOT EOF(1) THEN
        '    DIM tmpfile AS STRING
        '    DIM bytes(tsize) AS _UNSIGNED _BYTE
        '    tmpfile = __GXFS_RemoveFileExtension(__GXFS_GetFilename(filename)) + ".ts1"
        '    IF NOT _DIREXISTS("./tmp") THEN MKDIR ("./tmp")
        '    tilesetFilename = "./tmp/" + tmpfile
        '    GET #1, , bytes()
        '    OPEN tilesetFilename FOR BINARY AS #2
        '    PUT #2, , bytes()
        '    CLOSE #2
        '    GXTilesetCreate tilesetFilename, tilewidth, tileheight
        'ELSE
        '    GXTilesetCreate tilesetFilename, tilewidth, tileheight
        'END IF

    END SUB


    ' Load a version 1 map
    SUB __GX_MapLoadV1 (filename AS STRING)
        DIM columns AS INTEGER
        DIM rows AS INTEGER
        DIM col AS INTEGER
        DIM row AS INTEGER
        DIM layer AS INTEGER
        DIM depth AS INTEGER
        DIM tile AS INTEGER

        GET #1, , columns
        GET #1, , rows

        GXMapCreate columns, rows, 3
        __gx_map.version = 1

        FOR row = 0 TO rows - 1
            FOR col = 0 TO columns - 1
                GET #1, , depth
                IF depth > 0 THEN
                    FOR layer = 1 TO depth
                        GET #1, , tile
                        GXMapTile col, row, layer, tile + 1
                    NEXT layer
                END IF
            NEXT col
        NEXT row

        ' Read the tileset information
        DIM tilesetFilename AS STRING
        DIM tilewidth AS INTEGER
        DIM tileheight AS INTEGER
        tilesetFilename = __GX_ReadString_V1 ' original tileset filename
        GET #1, , tilewidth
        GET #1, , tileheight

        ' If the map has an embedded tileset image, save it to a temp file location
        DIM tsize AS LONG
        GET #1, , tsize
        IF NOT EOF(1) THEN
            DIM tmpfile AS STRING
            DIM bytes(tsize) AS _UNSIGNED _BYTE
            tmpfile = GXFS_RemoveFileExtension(GXFS_GetFilename(filename)) + ".ts1"
            IF NOT _DIREXISTS("./tmp") THEN MKDIR ("./tmp")
            tilesetFilename = "./tmp/" + tmpfile
            GET #1, , bytes()
            OPEN tilesetFilename FOR BINARY AS #2
            PUT #2, , bytes()
            CLOSE #2
            GXTilesetCreate tilesetFilename, tilewidth, tileheight
        ELSE
            GXTilesetCreate tilesetFilename, tilewidth, tileheight
        END IF
    END SUB



    FUNCTION GXMapIsometric
        GXMapIsometric = __gx_map.isometric
    END FUNCTION

    SUB GXMapIsometric (iso AS INTEGER)
        __gx_map.isometric = iso
        __GX_UpdateSceneSize
    END SUB


    SUB GXSpriteDraw (i AS LONG, x AS LONG, y AS LONG, seq AS INTEGER, frame AS INTEGER, swidth AS INTEGER, sheight AS INTEGER, imgdest AS LONG)
        GXSpriteDrawScaled i, x, y, swidth, sheight, seq, frame, swidth, sheight, imgdest
    END SUB

    SUB GXSpriteDrawScaled (i AS LONG, x AS LONG, y AS LONG, dwidth AS INTEGER, dheight AS INTEGER, seq AS INTEGER, frame AS INTEGER, swidth AS INTEGER, sheight AS INTEGER, imgdest AS LONG)
        DIM xoffset, yoffset
        xoffset = (frame - 1) * swidth
        yoffset = (seq - 1) * sheight
        IF imgdest THEN
            _PUTIMAGE (x, y)-(x + (dwidth - 1), y + (dheight - 1)), i, imgdest, (xoffset, yoffset)-(xoffset + (swidth - 1), yoffset + (sheight - 1))
        ELSE
            _PUTIMAGE (x, y)-(x + (dwidth - 1), y + (dheight - 1)), i, , (xoffset, yoffset)-(xoffset + (swidth - 1), yoffset + (sheight - 1))
        END IF
    END SUB


    ' Tileset Methods
    ' ----------------------------------------------------------------------------
    SUB GXTilesetCreate (tilesetFilename AS STRING, tileWidth AS INTEGER, tileHeight AS INTEGER)
        GXTilesetReplaceImage tilesetFilename, tileWidth, tileHeight

        REDIM __gx_tileset_tiles(GXTilesetColumns * GXTilesetRows) AS GXTile
        'REDIM __gx_tileset_animations(0) AS GXTile
    END SUB

    SUB GXTilesetReplaceImage (tilesetFilename AS STRING, tilewidth AS INTEGER, tileheight AS INTEGER)
        __gx_tileset.filename = tilesetFilename
        __gx_tileset.width = tilewidth
        __gx_tileset.height = tileheight

        DIM tswidth, tsheight
        __gx_tileset.image = __GX_ImageLoad(tilesetFilename)
        tswidth = _WIDTH(GXTilesetImage)
        tsheight = _HEIGHT(GXTilesetImage)

        __gx_tileset.columns = tswidth / GXTilesetWidth
        __gx_tileset.rows = tsheight / GXTilesetHeight

        'gx_scene.columns = FIX(gx_scene.width / gx_tileset.width)
        'gx_scene.rows = FIX(gx_scene.height / gx_tileset.height)
        __GX_UpdateSceneSize
    END SUB

    SUB GXTilesetLoad (filename AS STRING)
        OPEN filename FOR BINARY AS #1
        __GX_TilesetLoad
        CLOSE #1
    END SUB

    SUB __GX_TilesetLoad
        DIM version AS INTEGER
        version = 1

        ' Save the tileset version
        GET #1, , version

        ' Save the tileset image meta-data
        __gx_tileset.filename = __GX_ReadString
        GET #1, , __gx_tileset.width
        GET #1, , __gx_tileset.height

        ' Read the tileset image data and save to a temporary location
        DIM tsize AS LONG
        GET #1, , tsize
        DIM tmpfile AS STRING
        DIM tilesetFilename AS STRING
        DIM bytes(tsize) AS _UNSIGNED _BYTE
        tmpfile = GXFS_RemoveFileExtension(GXFS_GetFilename(GXTilesetFilename)) + ".gxi"
        IF NOT _DIREXISTS("./tmp") THEN MKDIR ("./tmp")
        tilesetFilename = "./tmp/" + tmpfile
        GET #1, , bytes()
        OPEN tilesetFilename FOR BINARY AS #2
        PUT #2, , bytes()
        CLOSE #2
        GXTilesetCreate tilesetFilename, GXTilesetWidth, GXTilesetHeight

        ' Read the tileset tile data
        DIM asize AS INTEGER
        GET #1, , asize
        REDIM __gx_tileset_tiles(asize) AS GXTile
        GET #1, , __gx_tileset_tiles()

        ' Read the tileset animation data
        GET #1, , asize
        REDIM __gx_tileset_animations(asize) AS GXTileFrame
        GET #1, , __gx_tileset_animations()
    END SUB

    SUB GXTilesetSave (filename AS STRING)
        OPEN filename FOR BINARY AS #1
        __GX_TilesetSave
        CLOSE #1
    END SUB

    SUB __GX_TilesetSave
        DIM version AS INTEGER
        version = 1

        ' Save the tileset version
        PUT #1, , version

        ' Save the tileset image meta-data
        __GX_WriteString GXTilesetFilename
        PUT #1, , __gx_tileset.width
        PUT #1, , __gx_tileset.height

        ' Save the tileset image data
        DIM tsize AS LONG
        OPEN GXTilesetFilename FOR BINARY AS #2
        tsize = LOF(2)
        PUT #1, , tsize

        DIM bytes(tsize) AS _UNSIGNED _BYTE
        GET #2, , bytes()
        PUT #1, , bytes()
        CLOSE #2

        ' Save the tileset tile data
        DIM asize AS INTEGER
        asize = UBOUND(__gx_tileset_tiles)
        PUT #1, , asize
        PUT #1, , __gx_tileset_tiles()

        ' Save the tileset animation data
        asize = UBOUND(__gx_tileset_animations)
        PUT #1, , asize
        PUT #1, , __gx_tileset_animations()
    END SUB

    SUB GXTilesetPos (tilenum AS INTEGER, p AS GXPosition)
        IF GXTilesetColumns = 0 THEN
            p.x = 0
            p.y = 0
        ELSE
            p.y = FIX((tilenum - 1) / GXTilesetColumns)
            p.y = p.y + 1
            p.x = (tilenum - 1) MOD GXTilesetColumns + 1
        END IF
    END SUB

    FUNCTION GXTilesetWidth
        GXTilesetWidth = __gx_tileset.width
    END FUNCTION

    FUNCTION GXTilesetHeight
        GXTilesetHeight = __gx_tileset.height
    END FUNCTION

    FUNCTION GXTilesetColumns
        GXTilesetColumns = __gx_tileset.columns
    END FUNCTION

    FUNCTION GXTilesetRows
        GXTilesetRows = __gx_tileset.rows
    END FUNCTION

    FUNCTION GXTilesetFilename$
        GXTilesetFilename = __gx_tileset.filename
    END FUNCTION

    FUNCTION GXTilesetImage
        GXTilesetImage = __gx_tileset.image
    END FUNCTION

    SUB GXTilesetAnimationCreate (tileId AS INTEGER, animationSpeed AS INTEGER)
        DIM frameId AS INTEGER
        frameId = UBOUND(__gx_tileset_animations) + 1
        REDIM _PRESERVE __gx_tileset_animations(frameId) AS GXTileFrame
        __gx_tileset_animations(frameId).tileId = tileId
        __gx_tileset_animations(frameId).firstFrame = frameId
        __gx_tileset_tiles(tileId).animationId = frameId
        __gx_tileset_tiles(tileId).animationSpeed = animationSpeed
    END SUB

    SUB GXTilesetAnimationAdd (firstTileId AS INTEGER, addTileId AS INTEGER)
        DIM firstFrame AS INTEGER
        firstFrame = __gx_tileset_tiles(firstTileId).animationId

        ' find the last frame
        DIM lastFrame AS INTEGER
        lastFrame = firstFrame
        WHILE __gx_tileset_animations(lastFrame).nextFrame > 0
            lastFrame = __gx_tileset_animations(lastFrame).nextFrame
        WEND

        DIM frameId AS INTEGER
        frameId = UBOUND(__gx_tileset_animations) + 1
        REDIM _PRESERVE __gx_tileset_animations(frameId) AS GXTileFrame
        __gx_tileset_animations(frameId).tileId = addTileId
        __gx_tileset_animations(frameId).firstFrame = firstFrame
        __gx_tileset_animations(lastFrame).nextFrame = frameId
    END SUB

    SUB GXTilesetAnimationRemove (firstTileId AS INTEGER)
        ' TODO: replace with implementation that will remove unused
        '       animation data from the array
        __gx_tileset_tiles(firstTileId).animationId = 0
    END SUB

    FUNCTION GXTilesetAnimationFrames (tileId AS INTEGER, tileFrames() AS INTEGER)
        IF tileId < 0 OR tileId > GXTilesetRows * GXTilesetColumns THEN
            GXTilesetAnimationFrames = 0
            EXIT SUB
        END IF

        REDIM tileFrames(0) AS INTEGER
        DIM frame AS INTEGER
        DIM frameCount AS INTEGER
        frameCount = 0
        frame = __gx_tileset_tiles(tileId).animationId
        WHILE frame > 0
            frameCount = frameCount + 1
            REDIM _PRESERVE tileFrames(frameCount) AS INTEGER
            tileFrames(frameCount) = __gx_tileset_animations(frame).tileId
            frame = __gx_tileset_animations(frame).nextFrame
        WEND
        GXTilesetAnimationFrames = frameCount
    END FUNCTION

    FUNCTION GXTilesetAnimationSpeed (tileId AS INTEGER)
        IF tileId > GXTilesetRows * GXTilesetColumns THEN EXIT SUB
        GXTilesetAnimationSpeed = __gx_tileset_tiles(tileId).animationSpeed
    END FUNCTION

    SUB GXTilesetAnimationSpeed (tileId AS INTEGER, speed AS INTEGER)
        'IF tileId < 1 THEN EXIT SUB

        'DIM firstFrame AS INTEGER
        'firstFrame = gx_tileset_tiles(tileId).animationId
        'IF firstFrame < 1 THEN EXIT SUB

        'gx_tileset_animations(firstFrame).animationSpeed = speed
        __gx_tileset_tiles(tileId).animationSpeed = speed
    END SUB

    ' Bitmap Font Methods
    ' ----------------------------------------------------------------------------
    FUNCTION GXFontCreate (filename AS STRING, charWidth AS INTEGER, charHeight AS INTEGER, charref AS STRING)
        __gx_font_count = __gx_font_count + 1
        REDIM _PRESERVE __gx_fonts(__gx_font_count) AS GXFont
        REDIM _PRESERVE __gx_font_charmap(256, __gx_font_count) AS GXPosition

        ' Create a new game entity
        __gx_fonts(__gx_font_count).eid = GXEntityCreate(filename, charWidth, charHeight, 1)
        ' Hide the entity as we will not be displaying it as a normal sprite
        GXEntityHide __gx_fonts(__gx_font_count).eid

        ' map the character codes to the image location
        __GX_FontMapChars __gx_font_count, charref

        GXFontCreate = __gx_font_count
    END FUNCTION

    SUB GXFontCreate (filename AS STRING, charWidth AS INTEGER, charHeight AS INTEGER, charref AS STRING, uid AS STRING)
        DIM fid AS INTEGER
        fid = GXFontCreate(filename, charWidth, charHeight, charref)
        __GX uid, fid, GXTYPE_FONT
    END SUB

    FUNCTION GXFontWidth (fid AS LONG)
        GXFontWidth = GXEntityWidth(__gx_fonts(fid).eid)
    END FUNCTION

    FUNCTION GXFontHeight (fid AS LONG)
        GXFontHeight = GXEntityHeight(__gx_fonts(fid).eid)
    END FUNCTION

    FUNCTION GXFontCharSpacing% (fid AS LONG)
        GXFontCharSpacing = __gx_fonts(fid).charSpacing
    END FUNCTION

    SUB GXFontCharSpacing (fid AS LONG, charSpacing AS INTEGER)
        __gx_fonts(fid).charSpacing = charSpacing
    END SUB

    FUNCTION GXFontLineSpacing% (fid AS LONG)
        GXFontLineSpacing = __gx_fonts(fid).lineSpacing
    END FUNCTION

    SUB GXFontLineSpacing (fid AS LONG, lineSpacing AS INTEGER)
        __gx_fonts(fid).lineSpacing = lineSpacing
    END SUB

    SUB GXDrawText (fid AS INTEGER, sx AS LONG, sy AS LONG, s AS STRING)
        IF fid = GXFONT_DEFAULT OR fid = GXFONT_DEFAULT_BLACK THEN
            IF __gx_fonts(fid).eid = 0 THEN __GX_FontCreateDefault fid
        END IF

        DIM i AS INTEGER
        DIM a AS INTEGER
        DIM c AS STRING
        DIM cpos AS GXPosition
        DIM x AS LONG: x = sx
        DIM y AS LONG: y = sy
        DIM font AS GXFont: font = __gx_fonts(fid)
        DIM e AS GXEntity: e = __gx_entities(font.eid)

        FOR i = 1 TO LEN(s)
            c = MID$(s, i, 1)
            a = ASC(c)
            IF a = 10 THEN ' Line feed, move down to the next line
                x = sx
                y = y + e.height + font.lineSpacing
            ELSEIF NOT a = 13 THEN ' Ignore Carriage Return
                IF NOT a = 32 THEN ' Space character, nothing to draw
                    cpos = __gx_font_charmap(a, fid)
                    GXSpriteDraw e.image, x, y, cpos.y, cpos.x, e.width, e.height, 0
                END IF
                x = x + e.width + font.charSpacing
            END IF
        NEXT i
    END SUB



    ' Debugging methods
    ' ----------------------------------------------------------------------------
    FUNCTION GXDebug
        GXDebug = __gx_debug.enabled
    END FUNCTION

    SUB GXDebug (enabled AS INTEGER)
        __gx_debug.enabled = enabled
    END SUB

    FUNCTION GXDebugScreenEntities
        GXDebugScreenEntities = __gx_debug.screenEntities
    END FUNCTION

    SUB GXDebugScreenEntities (enabled AS INTEGER)
        __gx_debug.screenEntities = enabled
    END SUB

    FUNCTION GXDebugFont%
        GXDebugFont = __gx_debug.font
    END FUNCTION

    SUB GXDebugFont (font AS INTEGER)
        __gx_debug.font = font
    END SUB

    FUNCTION GXDebugTileBorderColor~&
        GXDebugTileBorderColor = __gx_debug.tileBorderColor
    END FUNCTION

    SUB GXDebugTileBorderColor (c AS _UNSIGNED LONG)
        __gx_debug.tileBorderColor = c
    END SUB

    FUNCTION GXDebugEntityBorderColor~&
        GXDebugEntityBorderColor = __gx_debug.entityBorderColor
    END FUNCTION

    SUB GXDebugEntityBorderColor (c AS _UNSIGNED LONG)
        __gx_debug.entityBorderColor = c
    END SUB

    FUNCTION GXDebugEntityCollisionColor~&
        GXDebugEntityCollisionColor = __gx_debug.entityBorderColor
    END FUNCTION

    SUB GXDebugEntityCollisionColor (c AS _UNSIGNED LONG)
        __gx_debug.entityCollisionColor = c
    END SUB

    SUB __GX_DebugMapTile
        DIM t AS INTEGER, tx AS LONG, ty AS LONG, depth AS INTEGER, i AS INTEGER
        DIM tpos AS GXPosition
        '__GX_MapTilePosAt _MOUSEX, _MOUSEY, tpos
        GXMapTilePosAt GXMouseX, GXMouseY, tpos
        depth = GXMapTileDepth(tpos.x, tpos.y)
        tx = tpos.x * GXTilesetWidth - GXSceneX
        ty = tpos.y * GXTilesetHeight - GXSceneY

        DIM cdest AS LONG
        cdest = _DEST
        _DEST __gx_scene.image
        LINE (tx, ty)-(tx + GXTilesetWidth - 1, ty + GXTilesetHeight - 1), GXDebugTileBorderColor, B , &B1010101010101010
        GXDrawText GXDebugFont, tx, ty - 8, "(" + _TRIM$(STR$(tpos.x)) + "," + _TRIM$(STR$(tpos.y)) + ")"
        FOR i = 1 TO depth
            t = GXMapTile(tpos.x, tpos.y, i)
            GXDrawText GXDebugFont, tx, ty + GXTilesetHeight + 1 + (i - 1) * 8, _TRIM$(STR$(i)) + ":" + _TRIM$(STR$(t))
        NEXT i

        _DEST cdest
    END SUB

    SUB __GX_DebugEntity (ent AS GXEntity, x, y)
        IF ent.screen AND NOT GXDebugScreenEntities THEN EXIT SUB

        DIM odest AS LONG
        odest = _DEST
        _DEST __gx_scene.image

        ' Display the entity's position
        GXDrawText GXDebugFont, x, y - 8, "(" + __GX_DebugRound(ent.x, 2) + "," + __GX_DebugRound(ent.y, 2) + ")"

        ' Draw the entity's bounding rect
        LINE (x, y)-(x + ent.width - 1, y + ent.height - 1), GXDebugEntityBorderColor, B , &B1010101010101010

        ' Draw the entity's collision rect
        LINE (x + ent.coLeft, y + ent.coTop)-(x + ent.width - 1 - ent.coRight, y + ent.height - 1 - ent.coBottom), GXDebugEntityCollisionColor, B ', &B1010101010101010

        _DEST odest
    END SUB

    FUNCTION __GX_DebugRound$ (n AS DOUBLE, decimalPlaces AS INTEGER)
        DIM n2 AS LONG
        n2 = _ROUND(n * 10 ^ decimalPlaces)
        IF n2 = 0 THEN
            __GX_DebugRound = "0." + STRING$(decimalPlaces, "0")
        ELSE
            DIM ns AS STRING, decimal AS STRING
            ns = _TRIM$(STR$(n2))
            decimal = RIGHT$(ns, decimalPlaces)
            ns = LEFT$(ns, LEN(ns) - decimalPlaces)
            __GX_DebugRound = ns + "." + decimal
        END IF
    END FUNCTION

    SUB __GX_DebugFrameRate
        DIM frame AS STRING
        DIM frameRate AS STRING
        frame = _TRIM$(STR$(GXFrame))
        frameRate = _TRIM$(STR$(GXFrameRate))
        frameRate = STRING$(LEN(frame) - LEN(frameRate), " ") + frameRate

        DIM odest AS LONG
        odest = _DEST
        _DEST __gx_scene.image
        GXDrawText GXDebugFont, GXSceneWidth - (LEN(frame) + 6) * 6 - 1, 1, "FRAME:" + frame
        GXDrawText GXDebugFont, GXSceneWidth - (LEN(frameRate) + 4) * 6 - 1, 9, "FPS:" + frameRate
        _DEST odest
    END SUB



    ' GX Engine Miscellaneous Private Methods
    ' ----------------------------------------------------------------------------
    FUNCTION __GX_ImageLoad (filename AS STRING)
        DIM id AS LONG
        DIM i AS INTEGER
        FOR i = 0 TO __gx_image_count - 1
            IF filename = __gx_images(i).filename THEN id = __gx_images(i).id
        NEXT i
        IF id = 0 THEN
            id = _LOADIMAGE(filename, 32) ', 33)
            __gx_image_count = __gx_image_count + 1
            REDIM _PRESERVE __gx_images(__gx_image_count) AS GXImage
            __gx_images(__gx_image_count - 1).id = id
            __gx_images(__gx_image_count - 1).filename = filename
        END IF
        __GX_ImageLoad = id
    END FUNCTION


    SUB __GX_UpdateSceneSize
        IF GXTilesetWidth < 1 OR GXTilesetHeight < 1 THEN EXIT SUB
        IF GXMapIsometric THEN
            __gx_scene.columns = FIX(GXSceneWidth / GXTilesetWidth)
            'gx_scene.rows = FIX(GXSceneHeight / (GXTilesetHeight * .25))
            __gx_scene.rows = GXSceneHeight / (GXTilesetWidth / 4)
        ELSE
            __gx_scene.columns = FIX(GXSceneWidth / GXTilesetWidth)
            __gx_scene.rows = FIX(GXSceneHeight / GXTilesetHeight)
        END IF
    END SUB

    SUB __GX_WriteString (s AS STRING)
        DIM l AS LONG
        l = LEN(s)
        PUT #1, , l
        PUT #1, , s
    END SUB

    FUNCTION __GX_ReadString$
        DIM s AS STRING
        DIM l AS LONG
        DIM i AS INTEGER
        GET #1, , l
        s = STRING$(l, " ")
        GET #1, , s
        __GX_ReadString = s
    END FUNCTION

    FUNCTION __GX_ReadString_V1$
        DIM s AS STRING
        DIM l AS INTEGER
        DIM i AS INTEGER
        DIM b AS _UNSIGNED _BYTE
        GET #1, , l
        FOR i = 1 TO l
            GET #1, , b
            s = s + CHR$(b)
        NEXT i
        __GX_ReadString_V1 = s
    END FUNCTION

    FUNCTION __GX_EntityCollide (eid1, eid2)
        __GX_EntityCollide = __GX_RectCollide(GXEntityX(eid1), GXEntityY(eid1), GXEntityWidth(eid1), GXEntityHeight(eid1), GXEntityX(eid2), GXEntityY(eid2), GXEntityWidth(eid2), GXEntityHeight(eid2))
    END FUNCTION

    FUNCTION __GX_RectCollide (r1x1%, r1y1%, r1w%, r1h%, r2x1%, r2y1%, r2w%, r2h%)

        DIM r1x2%, r1y2%, r2x2%, r2y2%
        r1x2% = r1x1% + r1w%
        r1y2% = r1y1% + r1h%
        r2x2% = r2x1% + r2w%
        r2y2% = r2y1% + r2h%

        __GX_RectCollide = 0
        IF r1x2% >= r2x1% THEN
            IF r1x1% <= r2x2% THEN
                IF r1y2% >= r2y1% THEN
                    IF r1y1% <= r2y2% THEN
                        __GX_RectCollide = 1
                    END IF
                END IF
            END IF
        END IF

    END FUNCTION

    SUB __GX_FontMapChars (fid AS LONG, charref AS STRING)
        DIM cx AS INTEGER, cy AS INTEGER, i AS INTEGER, a AS INTEGER
        cx = 1
        cy = 1
        FOR i = 1 TO LEN(charref)
            a = ASC(MID$(charref, i, 1))
            IF a = 10 THEN
                cx = 1
                cy = cy + 1
            ELSE
                IF a >= 33 AND a <= 256 THEN
                    __gx_font_charmap(a, fid).x = cx
                    __gx_font_charmap(a, fid).y = cy
                END IF
                cx = cx + 1
            END IF
        NEXT i
    END SUB

    SUB __GX_FontCreateDefault (fid AS LONG)
        DIM filename AS STRING
        IF fid = GXFONT_DEFAULT_BLACK THEN
            __gx_font_default_black
            filename = "tmp/__gx_font_default_black.png"
        ELSE
            __gx_font_default
            filename = "tmp/__gx_font_default.png"
        END IF

        __gx_fonts(fid).eid = GXEntityCreate(filename, 6, 8, 1)
        KILL filename
        GXEntityHide __gx_fonts(fid).eid
        __GX_FontMapChars fid, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~`!@#$%^&*()_-+={}[]|\,./<>?:;" + CHR$(34) + "'"
        GXFontLineSpacing fid, 1
    END SUB


    FUNCTION __GX_EntityTestMove (entity AS INTEGER, mx AS LONG, my AS LONG, tpos AS GXPosition, collisionEntity AS INTEGER)
        tpos.x = -1
        tpos.y = -1
        'IF nocollision THEN GX_EntityTestMove = 1: EXIT FUNCTION

        DIM tcount AS INTEGER
        REDIM tiles(0) AS GXPosition
        __GX_EntityCollisionTiles entity, mx, my, tiles(), tcount


        DIM move AS INTEGER
        move = 1

        ' Test for tile collision
        DIM i AS INTEGER, j AS INTEGER
        DIM tile AS INTEGER
        FOR i = 0 TO tcount - 1
            'FOR j = 1 TO GXMapTileDepth(tiles(i).x, tiles(i).y)
            'tile = GXMapTile(tiles(i).x, tiles(i).y, j)
            DIM e AS GXEvent
            e.entity = entity
            e.event = GXEVENT_COLLISION_TILE
            e.collisionTileX = tiles(i).x
            e.collisionTileY = tiles(i).y
            GXOnGameEvent e
            IF e.collisionResult THEN
                move = 0
                tpos = tiles(i)
            END IF
            'NEXT j
        NEXT i

        ' Test for entity collision
        DIM entities(0) AS INTEGER
        DIM ecount AS INTEGER
        ecount = __GX_EntityCollision(entity, mx, my, entities())
        FOR i = 1 TO ecount
            DIM ee AS GXEvent
            ee.entity = entity
            ee.event = GXEVENT_COLLISION_ENTITY
            ee.collisionEntity = entities(i)
            GXOnGameEvent ee
            IF ee.collisionResult THEN
                move = 0
                collisionEntity = entities(i)
            END IF
        NEXT i

        __GX_EntityTestMove = move
    END FUNCTION

    FUNCTION __GX_EntityCollision (eid AS INTEGER, movex AS INTEGER, movey AS INTEGER, entities() AS INTEGER) ', ecount AS INTEGER)
        DIM ecount AS INTEGER
        ecount = 0

        DIM i AS INTEGER
        FOR i = 1 TO __gx_entity_count
            IF i <> eid THEN
                ' TODO: only include entities that should be considered (e.g. visible, non-screen-level)
            IF __GX_RectCollide(GXEntityX(eid) + GXEntityCollisionOffsetLeft(eid) + movex, _
               GXEntityY(eid) + GXEntityCollisionOffsetTop(eid) + movey, _
               GXEntityWidth(eid) - GXEntityCollisionOffsetLeft(eid) - GXEntityCollisionOffsetRight(eid), _
               GXEntityHeight(eid) - GXEntityCollisionOffsetTop(eid) - GXEntityCollisionOffsetBottom(eid), _
               GXEntityX(i) + GXEntityCollisionOffsetLeft(i), _
               GXEntityY(i) + GXEntityCollisionOffsetTop(i), _
               GXEntityWidth(i) - GXEntityCollisionOffsetLeft(i) - GXEntityCollisionOffsetRight(i), _
               GXEntityHeight(i) - GXEntityCollisionOffsetTop(i) - GXEntityCollisionOffsetBottom(i)) THEN
                    ecount = ecount + 1
                    REDIM _PRESERVE entities(ecount) AS INTEGER
                    entities(ecount) = i
                END IF
            END IF
        NEXT i

        __GX_EntityCollision = ecount
    END FUNCTION

    SUB __GX_EntityCollisionTiles (entity AS INTEGER, movex AS INTEGER, movey AS INTEGER, tiles() AS GXPosition, tcount AS INTEGER)
        DIM tx AS INTEGER, ty AS INTEGER
        DIM tx0 AS INTEGER, txn AS INTEGER
        DIM ty0 AS INTEGER, tyn AS INTEGER
        DIM x AS INTEGER, y AS INTEGER, i AS INTEGER

        IF movex <> 0 THEN
            DIM startx AS INTEGER
            startx = -1 + GXEntityCollisionOffsetLeft(entity) 'cx
            IF movex > 0 THEN startx = GXEntityWidth(entity) + movex - GXEntityCollisionOffsetRight(entity) 'cx2
            tx = FIX((GXEntityX(entity) + startx) / GXTilesetWidth)

            ' This is a real brute force way to find the intersecting tiles.
            ' We're basically testing every pixel along the edge of the entity's
            ' collision rect and incrementing the collision tile count.
            ' With a bit more math I'm sure we could avoid some extra loops here.
            tcount = 0
            ty0 = 0
            FOR y = GXEntityY(entity) + GXEntityCollisionOffsetTop(entity) TO GXEntityY(entity) + GXEntityHeight(entity) - 1 - GXEntityCollisionOffsetBottom(entity)
                ty = FIX(y / GXTilesetHeight)
                IF tcount = 0 THEN ty0 = ty
                IF NOT ty = tyn THEN
                    tcount = tcount + 1
                END IF
                tyn = ty
            NEXT y

            ' Add the range of detected tile positions to the return list
            REDIM tiles(tcount) AS GXPosition
            i = 0
            FOR ty = ty0 TO tyn
                tiles(i).x = tx
                tiles(i).y = ty
                i = i + 1
            NEXT ty
        END IF

        IF movey <> 0 THEN
            DIM starty AS INTEGER
            starty = -1 + GXEntityCollisionOffsetTop(entity) 'cy
            IF movey > 0 THEN starty = GXEntityHeight(entity) + movey - GXEntityCollisionOffsetBottom(entity) 'cy2
            ty = FIX((GXEntityY(entity) + starty) / GXTilesetHeight)

            ' This is a real brute force way to find the intersecting tiles.
            ' We're basically testing every pixel along the edge of the entity's
            ' collision rect and incrementing the collision tile count.
            ' With a bit more math I'm sure we could avoid some extra loops here.
            tcount = 0
            tx0 = 0
            FOR x = GXEntityX(entity) + GXEntityCollisionOffsetLeft(entity) TO GXEntityX(entity) + GXEntityWidth(entity) - 1 - GXEntityCollisionOffsetRight(entity)
                tx = FIX(x / GXTilesetWidth)
                IF tcount = 0 THEN tx0 = tx
                IF NOT tx = txn THEN
                    tcount = tcount + 1
                END IF
                txn = tx
            NEXT x


            REDIM tiles(tcount) AS GXPosition
            i = 0
            FOR tx = tx0 TO txn
                tiles(i).x = tx
                tiles(i).y = ty
                i = i + 1
            NEXT tx
        END IF
    END SUB

    SUB GXKeyInput (k AS LONG, di AS GXDeviceInput)
        di.deviceId = 1
        di.deviceType = GXDEVICE_KEYBOARD
        di.inputType = GXDEVICE_BUTTON
        di.inputId = k
        di.inputValue = -1
    END SUB

    FUNCTION GXKeyDown (k AS LONG)
        DIM di AS GXDeviceInput
        GXKeyInput k, di
        GXKeyDown = GXDeviceInputTest(di)
    END FUNCTION

    FUNCTION __GX_ActionTest (a AS GXAction)
        IF a.disabled THEN
            __GX_ActionTest = GX_FALSE
        ELSE
            DIM di AS GXDeviceInput
            __GX_ActionInput a, di
            __GX_ActionTest = GXDeviceInputTest(di)
        END IF
    END FUNCTION

    SUB __GX_PlayerAction (pid AS INTEGER)
        DIM tpos AS GXPosition
        DIM centity AS INTEGER

        DIM player AS GXPlayer
        player = __gx_players(pid)

        DIM actionLeft AS GXAction, actionRight AS GXAction, actionUp AS GXAction, actionDown AS GXAction
        DIM actionJump AS GXAction, actionJumpRight AS GXAction, actionJumpLeft AS GXAction
        actionLeft = __gx_player_keymap(GXACTION_MOVE_LEFT, pid)
        actionRight = __gx_player_keymap(GXACTION_MOVE_RIGHT, pid)
        actionUp = __gx_player_keymap(GXACTION_MOVE_UP, pid)
        actionDown = __gx_player_keymap(GXACTION_MOVE_DOWN, pid)
        actionJump = __gx_player_keymap(GXACTION_JUMP, pid)
        actionJumpRight = __gx_player_keymap(GXACTION_JUMP_RIGHT, pid)
        actionJumpLeft = __gx_player_keymap(GXACTION_JUMP_LEFT, pid)

        IF __GX_ActionTest(actionDown) THEN
            GXEntityAnimate player.eid, actionDown.animationSeq, actionDown.animationSpeed
            IF __GX_EntityTestMove(player.eid, 0, 1, tpos, centity) THEN
                __gx_entities(player.eid).vy = player.walkSpeed
            ELSE
                IF NOT __gx_entities(player.eid).applyGravity THEN __gx_entities(player.eid).vy = 0
            END IF
            __gx_entities(player.eid).vx = 0
            __GX_PlayerEvent pid, actionDown.type

        ELSEIF __GX_ActionTest(actionUp) THEN
            GXEntityAnimate player.eid, actionUp.animationSeq, actionUp.animationSpeed
            IF __GX_EntityTestMove(player.eid, 0, -1, tpos, centity) THEN
                __gx_entities(player.eid).vy = -player.walkSpeed
            ELSE
                IF NOT __gx_entities(player.eid).applyGravity THEN __gx_entities(player.eid).vy = 0
            END IF
            __gx_entities(player.eid).vx = 0
            __GX_PlayerEvent pid, actionUp.type

        ELSEIF __GX_ActionTest(actionRight) THEN
            GXEntityAnimate player.eid, actionRight.animationSeq, actionRight.animationSpeed
            IF __GX_EntityTestMove(player.eid, 1, 0, tpos, centity) THEN
                __gx_entities(player.eid).vx = player.walkSpeed
            ELSE
                __gx_entities(player.eid).vx = 0
            END IF
            IF __gx_entities(player.eid).applyGravity = 0 THEN __gx_entities(player.eid).vy = 0
            __GX_PlayerEvent pid, actionRight.type

        ELSEIF __GX_ActionTest(actionLeft) THEN
            GXEntityAnimate player.eid, actionLeft.animationSeq, actionLeft.animationSpeed
            IF __GX_EntityTestMove(player.eid, -1, 0, tpos, centity) THEN
                __gx_entities(player.eid).vx = -player.walkSpeed
            ELSE
                __gx_entities(player.eid).vx = 0
            END IF
            IF __gx_entities(player.eid).applyGravity = 0 THEN __gx_entities(player.eid).vy = 0
            __GX_PlayerEvent pid, actionLeft.type

        ELSE
            GXEntityAnimateStop player.eid
            __gx_entities(player.eid).vx = 0
            IF __gx_entities(player.eid).applyGravity = 0 THEN
                __gx_entities(player.eid).vy = 0
            END IF
        END IF

        IF __gx_entities(player.eid).applyGravity = 1 THEN
            IF __GX_ActionTest(actionJump) OR __GX_ActionTest(actionJumpLeft) OR __GX_ActionTest(actionJumpRight) THEN
                IF __GX_EntityTestMove(player.eid, 0, 1, tpos, centity) = 0 THEN
                    __gx_entities(player.eid).vy = -player.jumpSpeed
                    __gx_entities(player.eid).jumping = 1
                    __GX_PlayerEvent pid, GXACTION_JUMP
                END IF
            END IF

            IF __gx_entities(player.eid).jumping THEN
                IF __gx_entities(player.eid).vx < 0 AND actionJumpLeft.animationSeq THEN GXEntityAnimate player.eid, actionJumpLeft.animationSeq, actionJumpLeft.animationSpeed
                IF __gx_entities(player.eid).vx > 0 AND actionJumpRight.animationSeq THEN GXEntityAnimate player.eid, actionJumpRight.animationSeq, actionJumpRight.animationSpeed
            END IF
        END IF

    END SUB

    SUB __GX_PlayerEvent (player AS INTEGER, action AS INTEGER)
        DIM e AS GXEvent
        e.event = GXEVENT_PLAYER_ACTION
        e.player = player
        e.action = action
        GXOnGameEvent e
    END SUB


    SUB GXDeviceInputDetect (di AS GXDeviceInput)
        DIM found AS INTEGER
        DIM dcount AS INTEGER
        dcount = _DEVICES

        WHILE _DEVICEINPUT
            ' Flush the input buffer
        WEND

        DO
            _LIMIT 90
            DIM x AS INTEGER
            x = _DEVICEINPUT
            IF x THEN
                DIM i AS INTEGER
                FOR i = 1 TO _LASTBUTTON(x)
                    IF _BUTTON(i) THEN
                        di.deviceId = x
                        di.deviceType = __GX_DeviceTypeName(x)
                        di.inputType = GXDEVICE_BUTTON
                        di.inputId = i
                        di.inputValue = _BUTTON(i)
                        found = 1
                        EXIT DO
                    END IF
                NEXT i

                FOR i = 1 TO _LASTAXIS(x)
                    IF _AXIS(i) AND ABS(_AXIS(i)) = 1 THEN
                        di.deviceId = x
                        di.deviceType = __GX_DeviceTypeName(x)
                        di.inputType = GXDEVICE_AXIS
                        di.inputId = i
                        di.inputValue = _AXIS(i)
                        found = 1
                        EXIT DO
                    END IF
                NEXT i

                FOR i = 1 TO _LASTWHEEL(x)
                    IF _WHEEL(i) THEN
                        di.deviceId = x
                        di.deviceType = __GX_DeviceTypeName(x)
                        di.inputType = GXDEVICE_WHEEL
                        di.inputId = i
                        di.inputValue = _WHEEL(i)
                        found = 1
                        EXIT DO
                    END IF
                NEXT i
            END IF
        LOOP UNTIL found

        WHILE _DEVICEINPUT
            '    Flush the device input buffer
        WEND
        _KEYCLEAR

    END SUB

    FUNCTION __GX_DeviceTypeName (deviceId)
        DIM dname AS STRING
        dname = _DEVICE$(deviceId)

        IF INSTR(dname, "[KEYBOARD]") THEN
            __GX_DeviceTypeName = GXDEVICE_KEYBOARD
        ELSEIF INSTR(dname, "[MOUSE]") THEN
            __GX_DeviceTypeName = GXDEVICE_MOUSE
        ELSEIF INSTR(dname, "[CONTROLLER]") THEN
            __GX_DeviceTypeName = GXDEVICE_CONTROLLER
        END IF
    END FUNCTION

    FUNCTION GXDeviceName$ (deviceId AS INTEGER)
        DIM nstart AS INTEGER, nend AS INTEGER
        DIM dname AS STRING
        dname = _DEVICE$(deviceId)
        IF INSTR(dname, "[CONTROLLER]") THEN
            nstart = INSTR(dname, "[NAME]")
            IF nstart = 0 THEN
                dname = "Controller"
            ELSE
                nstart = nstart + 7
                nend = INSTR(nstart, dname, "]]")
                dname = _TRIM$(MID$(dname, nstart, nend - nstart))
            END IF
        ELSEIF INSTR(dname, "[MOUSE]") THEN
            dname = "Mouse"
        ELSEIF INSTR(dname, "[KEYBOARD]") THEN
            dname = "Keyboard"
        END IF
        GXDeviceName = dname
    END FUNCTION

    FUNCTION GXDeviceTypeName$ (dtype AS INTEGER)
        DIM dtypename AS STRING
        SELECT CASE dtype
            CASE GXDEVICE_KEYBOARD: dtypename = "KEYBOARD"
            CASE GXDEVICE_MOUSE: dtypename = "MOUSE"
            CASE GXDEVICE_CONTROLLER: dtypename = "CONTROLLER"
        END SELECT
        GXDeviceTypeName = dtypename
    END FUNCTION

    FUNCTION GXInputTypeName$ (itype AS INTEGER)
        DIM itypename AS STRING
        SELECT CASE itype
            CASE GXDEVICE_BUTTON: itypename = "BUTTON"
            CASE GXDEVICE_AXIS: itypename = "AXIS"
            CASE GXDEVICE_WHEEL: itypename = "WHEEL"
        END SELECT
        GXInputTypeName = itypename
    END FUNCTION

    FUNCTION GXKeyButtonName$ (inputId AS INTEGER)
        DIM k AS STRING
        SELECT CASE inputId
            CASE GXKEY_ESC: k = "Esc"
            CASE GXKEY_1: k = "1"
            CASE GXKEY_2: k = "2"
            CASE GXKEY_3: k = "3"
            CASE GXKEY_4: k = "4"
            CASE GXKEY_5: k = "5"
            CASE GXKEY_6: k = "6"
            CASE GXKEY_7: k = "7"
            CASE GXKEY_8: k = "8"
            CASE GXKEY_9: k = "9"
            CASE GXKEY_0: k = "0"
            CASE GXKEY_DASH: k = "-"
            CASE GXKEY_EQUALS: k = "="
            CASE GXKEY_BACKSPACE: k = "Bksp"
            CASE GXKEY_TAB: k = "Tab"
            CASE GXKEY_Q: k = "Q"
            CASE GXKEY_W: k = "W"
            CASE GXKEY_E: k = "E"
            CASE GXKEY_R: k = "R"
            CASE GXKEY_T: k = "T"
            CASE GXKEY_Y: k = "Y"
            CASE GXKEY_U: k = "U"
            CASE GXKEY_I: k = "I"
            CASE GXKEY_O: k = "O"
            CASE GXKEY_P: k = "P"
            CASE GXKEY_LBRACKET: k = "["
            CASE GXKEY_RBRACKET: k = "]"
            CASE GXKEY_ENTER: k = "Enter"
            CASE GXKEY_LCTRL: k = "LCtrl"
            CASE GXKEY_A: k = "A"
            CASE GXKEY_S: k = "S"
            CASE GXKEY_D: k = "D"
            CASE GXKEY_F: k = "F"
            CASE GXKEY_G: k = "G"
            CASE GXKEY_H: k = "H"
            CASE GXKEY_J: k = "J"
            CASE GXKEY_K: k = "K"
            CASE GXKEY_L: k = "L"
            CASE GXKEY_SEMICOLON: k = ";"
            CASE GXKEY_QUOTE: k = "'"
            CASE GXKEY_BACKQUOTE: k = "`"
            CASE GXKEY_LSHIFT: k = "LShift"
            CASE GXKEY_BACKSLASH: k = "\"
            CASE GXKEY_Z: k = "Z"
            CASE GXKEY_X: k = "X"
            CASE GXKEY_C: k = "C"
            CASE GXKEY_V: k = "V"
            CASE GXKEY_B: k = "B"
            CASE GXKEY_N: k = "N"
            CASE GXKEY_M: k = "M"
            CASE GXKEY_COMMA: k = ","
            CASE GXKEY_PERIOD: k = "."
            CASE GXKEY_SLASH: k = "/"
            CASE GXKEY_RSHIFT: k = "RShift"
            CASE GXKEY_NUMPAD_ASTERISK: k = "NPad *"
            CASE GXKEY_SPACEBAR: k = "Space"
            CASE GXKEY_CAPSLOCK: k = "CapsLk"
            CASE GXKEY_F1: k = "F1"
            CASE GXKEY_F2: k = "F2"
            CASE GXKEY_F3: k = "F3"
            CASE GXKEY_F4: k = "F4"
            CASE GXKEY_F5: k = "F5"
            CASE GXKEY_F6: k = "F6"
            CASE GXKEY_F7: k = "F7"
            CASE GXKEY_F8: k = "F8"
            CASE GXKEY_F9: k = "F9"
            CASE GXKEY_PAUSE: k = "Pause"
            CASE GXKEY_SCRLK: k = "ScrLk"
            CASE GXKEY_NUMPAD_7: k = "NPad 7"
            CASE GXKEY_NUMPAD_8: k = "NPad 8"
            CASE GXKEY_NUMPAD_9: k = "NPad 9"
            CASE GXKEY_NUMPAD_MINUS: k = "-"
            CASE GXKEY_NUMPAD_4: k = "NPad 4"
            CASE GXKEY_NUMPAD_5: k = "NPad 5"
            CASE GXKEY_NUMPAD_6: k = "NPad 6"
            CASE GXKEY_NUMPAD_PLUS: k = "+"
            CASE GXKEY_NUMPAD_1: k = "NPad 1"
            CASE GXKEY_NUMPAD_2: k = "NPad 2"
            CASE GXKEY_NUMPAD_3: k = "NPad 3"
            CASE GXKEY_NUMPAD_0: k = "NPad 0"
            CASE GXKEY_NUMPAD_PERIOD: k = "NPad ."
            CASE GXKEY_F11: k = "F11"
            CASE GXKEY_F12: k = "F12"
            CASE GXKEY_NUMPAD_ENTER: k = "NPad Enter"
            CASE GXKEY_RCTRL: k = "RCtrl"
            CASE GXKEY_NUMPAD_SLASH: k = "NPad /"
            CASE GXKEY_NUMLOCK: k = "NumLk"
            CASE GXKEY_HOME: k = "Home"
            CASE GXKEY_UP: k = "Up"
            CASE GXKEY_PAGEUP: k = "PgUp"
            CASE GXKEY_LEFT: k = "Left"
            CASE GXKEY_RIGHT: k = "Right"
            CASE GXKEY_END: k = "End"
            CASE GXKEY_DOWN: k = "Down"
            CASE GXKEY_PAGEDOWN: k = "PgDn"
            CASE GXKEY_INSERT: k = "Ins"
            CASE GXKEY_DELETE: k = "Del"
            CASE GXKEY_LWIN: k = "LWin"
            CASE GXKEY_RWIN: k = "RWin"
            CASE GXKEY_MENU: k = "Menu"
        END SELECT
        GXKeyButtonName = k
    END FUNCTION

    '$INCLUDE: 'gx_fs.bm'
    '$INCLUDE: 'resource/font-default.png.bm'
    '$INCLUDE: 'resource/font-default-black.png.bm'

$LET GXBM = 1
$END IF
